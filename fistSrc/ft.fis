def inline
global  _GSPMet
global  _GSaccumSFac
global  _GSapplyAlpha
global  _GSgetAlpha
global  _GSgetPebble
global  _GSgetRpo
global  _GSgetRpoBP
global  _GSiterN
global  _Lmax
global  _Lmin
global  _Vg
global  _aASTPPdone
global  _aASdone
global  _aASeincr
global  _aASmea0
global  _aASwea0
global  _aRSdone
global  _aRSeincr
global  _aRSwer0
global  _aRSwex0
global  _bVol
global  _cVol
global  _ckAddCrack
global  _ckBallBall
global  _ckBondBreak
global  _ckCodeDependencies
global  _ckCountCrack
global  _ckDFN
global  _ckDeformabilityRadius
global  _ckDiam
global  _ckGeom
global  _ckGeomContact
global  _ckGeomNoContact
global  _ckName
global  _ckNameFailMode
global  _ckNameType
global  _ckOn
global  _ckResetCrackData
global  _ckSize
global  _ckUpdate
global  _ckUpdateCnt
global  _clDiam
global  _ctApplyAxialPressure
global  _ctApplyAxialStrain
global  _ctApplyRadialStrain
global  _ctCheckParams
global  _ctEndStage
global  _ctExpandFac
global  _ctLoadTermSteps
global  _ctMatTestStr
global  _ctPerformStage
global  _ctTestStr
global  _ctUpdate_wsdMax
global  _d
global  _dcApplyAxialStrain
global  _dcCheckParams
global  _dcEndStage
global  _dcLoadTermSteps
global  _dcMakeWalls
global  _dcMatTestStr
global  _dcPerformStage
global  _dcSetWallVel
global  _dcTestStr
global  _dcUpdate_wfaMax
global  _denom
global  _dsc
global  _eqPMet
global  _eqPTol
global  _eqPreps
global  _eqPxeps
global  _eqPyeps
global  _eqPzeps
global  _frac
global  _ftAng2D
global  _ftAngMin
global  _ftCheckZeroTol
global  _ftCodeDependencies
global  _ftConstants
global  _ftInit
global  _ftModulus
global  _ftOneSixth
global  _ftOneThird
global  _gc
global  _gsdBounds
global  _gsdCalled
global  _gsdDmax
global  _gsdDmin
global  _gsdMakeGSD
global  _gsdMakeGSDretained
global  _iHatMax
global  _mFac
global  _mPos
global  _mRad
global  _minDim
global  _mpAssignCB
global  _mpAssignCBbond
global  _mpAssignFJ
global  _mpAssignFJProps
global  _mpAssignFJprops
global  _mpAssignPB
global  _mpAssignPBbond
global  _mpAssignPBprops
global  _mpAssignSB
global  _mpAssignSBbond
global  _mpAssignSBprops
global  _mpBallDistribute
global  _mpCheckAllParams
global  _mpCheckCBParams
global  _mpCheckCommonParams
global  _mpCheckFJParams
global  _mpCheckLinParams
global  _mpCheckPBParams
global  _mpCheckPackingParams
global  _mpCheckSBParams
global  _mpClumpDistribute
global  _mpCylRange
global  _mpCylRangeOUT
global  _mpCylRangeSup
global  _mpDeleteGrainsOutOfVessel
global  _mpFJrmulReduce
global  _mpFJrmulReduceAll
global  _mpFJrmulRemoveOverlap
global  _mpFJsetMicroStruc
global  _mpFinalizationPhase
global  _mpMSisNearZero
global  _mpMakeGrains
global  _mpMaxORisSmall
global  _mpPackBdryContract
global  _mpPackGrainScale
global  _mpPackIsoState
global  _mpPackingPhase
global  _mpSetEffLinBehavior
global  _mpSetGrainDamp
global  _mpSetGrainDensity
global  _mpSphRange
global  _mpSphRangeOUT
global  _mpSphRangeSup
global  _msArc
global  _msBoxDefined
global  _msBoxGeomSetUpdate
global  _msBoxGeomSetUpdated
global  _msBoxMarkGrains
global  _msCB_Make
global  _msCKAvgSize
global  _msCK_Make
global  _msCKdrawMe
global  _msCKthick
global  _msCircle2D
global  _msClear
global  _msCleared
global  _msCylinder
global  _msDisk
global  _msEtaDir
global  _msFG_Make
global  _msFGcoreRad
global  _msFGdrawCore
global  _msFGdrawFacedGrain
global  _msFGdrawSkirtedFaces
global  _msFGdrawSkirtedFaces2D
global  _msFGdrawSkirtedFaces3D
global  _msFJiDrawCoordSys
global  _msFJiDrawDisc
global  _msFJiDrawDisc2D
global  _msFJiDrawDisc3D
global  _msFJiDrawIntfc
global  _msFJi_Make
global  _msGN_Make
global  _msGrainPieceInBox
global  _msGrainPiecePt
global  _msLineA
global  _msLineB
global  _msLineThick2D
global  _msLocalS
global  _msNdir
global  _msOn
global  _msPBc_Make
global  _msPBi_Make
global  _msPoly3
global  _msPoly4
global  _msSBiGrpName
global  _msSBi_Make
global  _msSdir
global  _msSkirt
global  _msSphere
global  _msTdir
global  _msUpdate
global  _msUpdateCnt
global  _msXiDir
global  _msXidir
global  _mvCheckParams
global  _mvCylRes
global  _mvMakeMeasRegions
global  _mvMakeWalls
global  _mvMpAxLen
global  _mvMpDiam
global  _mvMpLength
global  _mvMpRadLenX
global  _mvMpRadLenY
global  _mvSBondBreak
global  _mvSbondBreak
global  _mvSgainPer
global  _mvShalt
global  _mvSignore
global  _mvSnumBreak
global  _mvSphRes
global  _mvSupdateSR
global  _mvVolume
global  _mv_wAreas
global  _mvsActive
global  _mvsCheckMeasWallOverlap
global  _mvsEnforceVlimit
global  _mvsGain
global  _mvsGainCnt
global  _mvsGainCompute
global  _mvsGainStored
global  _mvsRadForce
global  _mvsRadVel
global  _mvsSetRadVel
global  _mvsUpdateRadDiam
global  _nc
global  _pkORcnt
global  _pkORmaxLimit
global  _pkORupdateRate
global  _pkSavPreFinal
global  _rhoG
global  _spCarveFac
global  _spCheckParams
global  _spSS_L0
global  _spSS_bBot
global  _spSS_bTop
global  _spSSareaZ
global  _spSSarraysFill
global  _spSSbdryBot
global  _spSSbdryTop
global  _spSSnbdry
global  _spSSnbdryBot
global  _spSSnbdryTop
global  _str
global  _sumVg
global  _ttApplyAxialStrain
global  _ttCheckParams
global  _ttEndStage
global  _ttLoadTermSteps
global  _ttMatTestStr
global  _ttPerformStage
global  _ttSetGripVel
global  _ttTestStr
global  _ttUpdate_msaMax
global  _ttUpdate_tt_bea
global  _val
global  _wAr
global  _wAreaMode
global  _wAx
global  _wAy
global  _wAz
global  _wdHt
global  _wdr
global  _wdr0
global  _wdx
global  _wdx0
global  _wdy
global  _wdy0
global  _wdz
global  _wdz0
global  _xc
global  _xf
global  a
global  a1
global  a2
global  above
global  abs
global  achieved
global  active
global  add
global  af
global  al1
global  al2
global  aligned
global  all
global  alpha
global  alpha1
global  alpha2
global  always
global  an
global  and
global  angOut
global  angle
global  application
global  aratio
global  are
global  args
global  argument
global  around
global  as
global  assemble
global  assembled
global  at
global  atan2
global  attribute
global  available
global  average
global  avg
global  avgSize
global  axial
global  axis
global  azimuth
global  b1
global  b2
global  bLinearBased
global  bPtr
global  ball
global  balls
global  base
global  based
global  bcnMark
global  bcnMeasure
global  bcn_numGrains
global  be
global  been
global  before
global  begin
global  being
global  bending
global  beta
global  bin
global  bins
global  bond
global  bond_break
global  bonded
global  bonds
global  boundary
global  box
global  bp
global  bp_other
global  break
global  breakage
global  breaks
global  brick
global  brk
global  brokeShear
global  brokeTension
global  build
global  bulk
global  but
global  by
global  c1
global  c2
global  cGrainGrain
global  cGrainWall
global  cList
global  cNum
global  cPos
global  cSet
global  cType
global  cVec1
global  cVec2
global  call
global  callback
global  called
global  calling
global  calm
global  calming
global  cannot
global  cap
global  cb_state
global  cb_strength
global  cbm_emod
global  cbm_fric
global  cbm_igap
global  cbm_krat
global  cbm_shears_m
global  cbm_shears_sd
global  cbm_tens_m
global  cbm_tens_sd
global  cell
global  cement
global  center
global  centers
global  check
global  circumferential
global  ckDFN
global  ckFilter
global  ckFilterGap
global  ckFilterOpen
global  ckForceUpdate
global  ckGetDFN
global  ckGetSize
global  ckInit
global  ckInited
global  ckListData
global  ckOff
global  ckOn
global  ckType
global  ckUpdateRate
global  ck_nAll
global  ck_nCBs
global  ck_nCBt
global  ck_nFJs
global  ck_nFJt
global  ck_nFiltered
global  ck_nOrphans
global  ck_nPBs
global  ck_nPBt
global  ck_nSBs
global  ck_nSBt
global  ck_nSJs
global  ck_nSJt
global  cl
global  clean
global  clear
global  close
global  cloud
global  clump
global  clumps
global  cmName
global  cm_Dlo
global  cm_Dmult
global  cm_Dup
global  cm_Vfrac
global  cm_ctName
global  cm_densityCode
global  cm_densityVal
global  cm_localDampFac
global  cm_matName
global  cm_matNameSAV
global  cm_matType
global  cm_modName
global  cm_nSD
global  cm_shape
global  cm_typeSD
global  cmat
global  cnt
global  cntG
global  cntOR
global  code
global  coef
global  coefficient
global  cohesion
global  completed
global  compression
global  condition
global  confined
global  confinement
global  confining
global  consecutive
global  constant
global  contact
global  contactmap
global  contactmodelmechanical
global  contacts
global  continuing
global  contraction
global  contribution
global  control
global  coordination
global  core
global  cos
global  cp
global  cpFJ1
global  cpFJ2
global  crack
global  cracks
global  create
global  cross
global  ct
global  ctListProps
global  ctLoadingPhase
global  ctParams
global  ctPerformStages
global  ctSeatingPhase
global  ct_ARatLimit
global  ct_PTol
global  ct_Pc
global  ct_eRate
global  ct_loadCode
global  ct_loadFac
global  ct_loadStage
global  ct_stepLimit
global  ct_testType
global  ct_vLimit
global  ct_wsdMax
global  ct_wsdMax0
global  ctr
global  cuboid
global  curOR
global  current
global  cycle
global  cycles
global  cylDelHt
global  cylDelRad
global  cylRad
global  cylRadEx
global  cylinder
global  cylindrical
global  dFac
global  damp
global  damp_con
global  damping
global  dat
global  dc
global  dcBottom
global  dcListProps
global  dcLoadingPhase
global  dcParams
global  dcPerformStages
global  dcSetupPhase
global  dcTop
global  dcWp0
global  dcWp1
global  dc_ARatLimit
global  dc_d
global  dc_eRate
global  dc_emod
global  dc_g0
global  dc_loadCode
global  dc_loadFac
global  dc_loadStage
global  dc_stepLimit
global  dc_w
global  dc_wForce
global  dc_wForceZero
global  dc_wInit
global  dc_wRemove
global  dc_wStrain
global  dc_wStrainZero
global  dc_wda
global  dc_wea
global  dc_wfa
global  dc_wfaMax
global  dc_wfaMax0
global  decrease
global  default
global  defined
global  deformability
global  deforming
global  degrad
global  degrees
global  delAlpha
global  delMS
global  delTheta
global  del_a
global  del_phi
global  del_r
global  del_theta
global  delete
global  deltaX
global  denom
global  density
global  depth
global  derived
global  desired
global  deviation
global  dfn
global  diam
global  diameter
global  did
global  dim
global  dims
global  dir
global  direc
global  direction
global  disk
global  disks
global  displacement
global  displayed
global  distribute
global  distribution
global  distributions
global  do
global  does
global  domain
global  done
global  dot
global  dp_mode
global  dp_nratio
global  dp_sratio
global  drawMe
global  dry
global  during
global  e
global  eNum
global  eRate
global  e_incr
global  e_rate
global  edge
global  effective
global  elements
global  emod
global  end1
global  end2
global  entering
global  eps
global  epsP
global  eqPTol
global  equal
global  equil
global  equilibrium
global  error
global  errors
global  etaSys
global  euler
global  event
global  existing
global  exiting
global  export
global  extent
global  extra
global  f2
global  fName
global  face
global  faced
global  facet
global  factor
global  failMode
global  failed
global  failure
global  file
global  filename
global  find
global  fish
global  fix
global  fj_Nal
global  fj_Nr
global  fj_area
global  fj_cen
global  fj_coh
global  fj_egap
global  fj_elem
global  fj_fa
global  fj_fric
global  fj_gap0
global  fj_mtype
global  fj_nal
global  fj_nr
global  fj_radius
global  fj_relbr
global  fj_rmul
global  fj_state
global  fj_ten
global  fjm_
global  fjm_B_frac
global  fjm_G_frac
global  fjm_G_m
global  fjm_G_sd
global  fjm_Nal
global  fjm_Nr
global  fjm_S_frac
global  fjm_coh_m
global  fjm_coh_sd
global  fjm_emod
global  fjm_fa
global  fjm_fric
global  fjm_igap
global  fjm_krat
global  fjm_rmulCode
global  fjm_rmulVal
global  fjm_ten_m
global  fjm_ten_sd
global  fjm_trackMS
global  flag
global  flat
global  flatjoint
global  floor
global  force
global  fracSum
global  fraction
global  fracture
global  fracturelist
global  fric
global  fric_coef
global  friction
global  from
global  frozen
global  ft_OverlapRatios
global  ft_SaveState
global  ft_SetTitle
global  ft_SmoothGrainWallInterface
global  ft_ZeroGrainDisplacement
global  ft_bEuler
global  ft_bNumBond
global  ft_bRotation
global  ft_bRotationSet
global  ft_cAssignLinProps
global  ft_cBondIt
global  ft_cBondable
global  ft_cGrainGrain
global  ft_cGrainWall
global  ft_cLinearBased
global  ft_cPosPeriodic
global  ft_cexNum
global  ft_clNumBond
global  ft_eq
global  ft_mBonded
global  ft_setGrainWallBehavior
global  ft_setMatBehavior
global  ft_valNormDist
global  fully
global  function
global  future
global  gap
global  gapIn
global  gapInterval
global  gapped
global  gauss
global  gaussian
global  generate
global  generator
global  geom
global  gm
global  gn
global  grain
global  grains
global  greater
global  grip
global  gripVel
global  group
global  grpName
global  gs
global  gsdGetSizeOfPercentile
global  gsdMark
global  gsdMeasure
global  gsd_numGrains
global  halt
global  handle
global  handled
global  has
global  have
global  height
global  hill
global  history
global  hl_cHill
global  hlm_checkParams
global  hlm_computeMicroStrucProps
global  hlm_dampCon
global  hlm_fricCoef
global  hlm_listMicroStrucProps
global  hlm_listProps
global  hlm_makeDry
global  hlm_makeWet
global  hlm_mwCalled
global  hlm_mwMoisGap
global  hlm_mwSuction
global  hlm_poisRatio
global  hlm_setMatBehavior
global  hlm_suction
global  hlm_youngMod
global  i
global  iHat
global  id
global  idx
global  idxBot
global  idxTop
global  ignore
global  implemented
global  import
global  in
global  increment
global  inherit
global  inheritance
global  initDim
global  initial
global  initially
global  inline
global  installation
global  interface
global  interfaces
global  interval
global  into
global  io
global  is
global  j
global  jHat
global  jointed
global  justGrains
global  k_hat
global  kn
global  krat
global  kratio
global  lambda
global  last
global  lc
global  len
global  lenFac
global  lenHalf
global  lenX
global  lenY
global  lenZ
global  length
global  less
global  lf1
global  lf2
global  lies
global  limit
global  lin_mode
global  linear
global  linearcbond
global  linearpbond
global  listed
global  ll
global  lnm_emod
global  lnm_fric
global  lnm_krat
global  load
global  loadStage
global  loading
global  localdir
global  lower
global  mag
global  make
global  makeB
global  makeG
global  makeS
global  make_dry
global  make_wet
global  many
global  mass
global  mat
global  matB
global  matV
global  material
global  math
global  max
global  maxContacts
global  maxThick
global  maximum
global  may
global  mean
global  meanStress
global  measure
global  measurement
global  mech
global  median
global  met
global  method
global  microstructural
global  microstructure
global  min
global  minThick
global  mk
global  mode
global  model
global  modulus
global  mois_state
global  moisture
global  moment
global  monitoring
global  mpComputeMicroStrucProps
global  mpDavg
global  mpGrp
global  mpListCBProps
global  mpListCommonProps
global  mpListFJProps
global  mpListLinProps
global  mpListMicroProps
global  mpListMicroStrucProps
global  mpListPBProps
global  mpListPackingProps
global  mpListSBProps
global  mpMake
global  mpMakeFromBrick
global  mp_CNb
global  mp_D50
global  mp_Davg
global  mp_FromBrick
global  mp_ORavg
global  mp_ORmax
global  mp_ORmin
global  mp_ORs
global  mp_PhiV50
global  mp_PhiVavg
global  mp_nCBb
global  mp_nFJb
global  mp_nFJc
global  mp_nFJe
global  mp_nFJiB
global  mp_nFJiG
global  mp_nFJiS
global  mp_nFJiU
global  mp_nGN
global  mp_nHLc
global  mp_nHLms0
global  mp_nHLms1
global  mp_nHLms2
global  mp_nLNc
global  mp_nLNgg
global  mp_nLNgw
global  mp_nPBb
global  mp_nSBb
global  msActivate
global  msBox
global  msBoxCenter
global  msBoxDefine
global  msBoxDims
global  msBoxIN
global  msBoxOUT
global  msCB_sfacLen
global  msCK_ckFilter
global  msCK_sfacMaxThick
global  msCK_sfacMinThick
global  msCK_sfacSize
global  msFG_Track
global  msFG_TrackOn
global  msFG_cex1
global  msFG_cex2
global  msFG_cex3
global  msFG_cex4
global  msFG_seedID
global  msFG_seedNum
global  msFJi_sfacRad
global  msForceUpdate
global  msGN_sfacRad
global  msOff
global  msOn
global  msPBc_sfacLen
global  msPBc_sfacRad
global  msPBi_sfacRad
global  msSBi_sfacRad
global  msUpdateRate
global  ms_Sinstall
global  multiple
global  multiplier
global  must
global  mv
global  mvBottom
global  mvCyl
global  mvInstallStress
global  mvListProps
global  mvMake
global  mvMp1
global  mvMp2
global  mvMp3
global  mvSphere
global  mvTop
global  mvWp0x
global  mvWp0y
global  mvWp0z
global  mvWp1x
global  mvWp1y
global  mvWp1z
global  mvWpCyl
global  mvWpSph
global  mv_D
global  mv_H
global  mv_SARatLimit
global  mv_Semod
global  mv_Sinstall
global  mv_Stol
global  mv_Sx
global  mv_Sy
global  mv_Sz
global  mv_W
global  mv_emod
global  mv_expandFac
global  mv_inset
global  mv_insetDFac
global  mv_insetLFac
global  mv_mInit
global  mv_mPoros
global  mv_mRemove
global  mv_mStrain
global  mv_mStrainZero
global  mv_mStress
global  mv_mStressZero
global  mv_mea
global  mv_med
global  mv_mer
global  mv_mev
global  mv_mexx
global  mv_mexy
global  mv_mexz
global  mv_meyy
global  mv_meyz
global  mv_mezz
global  mv_mn
global  mv_msa
global  mv_msd
global  mv_msm
global  mv_msr
global  mv_msxx
global  mv_msxy
global  mv_msxz
global  mv_msyy
global  mv_msyz
global  mv_mszz
global  mv_perNx
global  mv_perNy
global  mv_perNz
global  mv_sInstall
global  mv_shape
global  mv_type
global  mv_wAreaMode
global  mv_wInit
global  mv_wPoros
global  mv_wPr
global  mv_wPx
global  mv_wPy
global  mv_wPz
global  mv_wRemove
global  mv_wStrain
global  mv_wStrainZero
global  mv_wStress
global  mv_wStressZero
global  mv_wea
global  mv_wed
global  mv_wer
global  mv_wev
global  mv_wex
global  mv_wey
global  mv_wez
global  mv_wn
global  mv_wsa
global  mv_wsd
global  mv_wsm
global  mv_wsr
global  mv_wsx
global  mv_wsy
global  mv_wsz
global  mvs_BCr
global  mvs_BCrVal
global  mvs_BCx
global  mvs_BCxVal
global  mvs_BCy
global  mvs_BCyVal
global  mvs_BCz
global  mvs_BCzVal
global  mvs_applyConfinement
global  mvs_eqP
global  mvs_gainUpdateRate
global  mvs_off
global  mvs_on
global  mvs_setBCs
global  mvs_vLimit
global  myCrk
global  mySize
global  myStr
global  myTen1
global  myTen2
global  myTen3
global  myTypeStr
global  n
global  n1
global  n2
global  nB
global  nBonds
global  nC
global  nDir
global  nE
global  nFJ
global  nFac
global  nFiltered
global  nG
global  nGN
global  nOrphans
global  nS
global  nSeg
global  name
global  names
global  nc
global  nd
global  near
global  nf
global  nfo
global  ninety
global  nk
global  nl
global  no
global  noFric
global  noProx
global  node
global  non
global  normal
global  not
global  notBCNsample
global  notFiltered
global  notGSDsample
global  note
global  now
global  np
global  nr

global  num
global  numBins
global  numBond
global  numDel
global  numFG
global  numGrains0
global  numGrains1
global  numSlots
global  number
global  numer
global  obtained
global  occurred
global  of
global  off
global  offset
global  on
global  one
global  only
global  opening
global  operating
global  or
global  order
global  orientation
global  origin
global  orphan
global  orphaned
global  out
global  outside
global  overlap
global  overlapSides
global  p
global  p1
global  p1c
global  p2
global  p2c
global  pInBox
global  pOut
global  pPos1
global  pPos2
global  pRad1
global  pRad2
global  pack
global  package
global  packing
global  parallel
global  parameter
global  parameters
global  pb
global  pb_coh
global  pb_deformability
global  pb_fa
global  pb_mcf
global  pb_radius
global  pb_rmul
global  pb_state
global  pb_ten
global  pbm_bemod
global  pbm_bkrat
global  pbm_coh_m
global  pbm_coh_sd
global  pbm_emod
global  pbm_fa
global  pbm_fric
global  pbm_igap
global  pbm_krat
global  pbm_mcf
global  pbm_rmul
global  pbm_ten_m
global  pbm_ten_sd
global  pbond
global  pct
global  pebble
global  pebblelist
global  pebbles
global  perV
global  performed
global  performing
global  periodic
global  phase
global  phi0
global  phi1
global  physical
global  pi
global  pieceRad1
global  pieceRad2
global  pk_ARatLimit
global  pk_PTol
global  pk_Pm
global  pk_fricCA
global  pk_nc
global  pk_procCode
global  pk_seed
global  pk_stepLimit
global  pk_vLimit
global  pl
global  planar
global  plane
global  planned
global  platen
global  plot
global  pointer
global  pointnear
global  pois_ratio
global  poly
global  polyaxial
global  polygon
global  porosity
global  pos
global  posBot
global  posObj
global  posS
global  posTop
global  position
global  positive
global  preFinal
global  preSoften
global  pressure
global  proc
global  procedure
global  program
global  prop
global  properties
global  property
global  provided
global  prox
global  proximity
global  psi
global  ptrObj
global  r
global  r1
global  r2
global  rVel
global  ra
global  radCore
global  radF
global  radIntfc
global  radial
global  radius
global  random
global  range
global  rate
global  ratio
global  ratioMax
global  ratios
global  rc
global  rd
global  reach
global  reached
global  real
global  rectangular
global  redefined
global  redefining
global  reduce
global  reduction
global  region
global  regions
global  relbrS
global  relbrT
global  remove
global  removed
global  requires
global  rerun
global  resolution
global  retCode
global  retained

global  returnCode
global  rf
global  rfMin
global  rgap
global  rot
global  rotation
global  round
global  rs
global  runName
global  ruptured
global  s
global  sFac
global  sHat
global  sav
global  save
global  sb_bmul
global  sb_coh
global  sb_cut
global  sb_fa
global  sb_mcf
global  sb_mode
global  sb_radius
global  sb_rmul
global  sb_soft
global  sb_state
global  sb_ten
global  sb_tmul
global  sbm_bkrat
global  sbm_bmul
global  sbm_coh_m
global  sbm_coh_sd
global  sbm_cut
global  sbm_emod
global  sbm_fa
global  sbm_fric
global  sbm_igap
global  sbm_krat
global  sbm_mcf
global  sbm_rmul
global  sbm_soft
global  sbm_ten_m
global  sbm_ten_sd
global  sbm_tmul
global  sbond
global  scalesphere
global  scaling
global  sdev
global  seating
global  seed
global  servo
global  set
global  sgn
global  shape
global  shear
global  side
global  sin
global  single
global  situation
global  size
global  sj_gap
global  sj_radius
global  sj_unorm
global  skip
global  skirt
global  skirted
global  slit
global  slot
global  slots
global  slt
global  smooth
global  smoothjoint
global  soft
global  softbond
global  softenElastic
global  softenPlastic
global  softening
global  solve
global  spCarve
global  spDavg
global  spListProps
global  sp_D
global  sp_H
global  sp_W
global  sp_carve
global  sp_expandFac
global  sp_insetDFac
global  sp_insetLFac
global  sp_sea
global  sp_shape
global  sp_ssa
global  sp_testType
global  sp_ttStressStrainInit
global  sp_wemod
global  space
global  spanning
global  specified
global  specify
global  sphRad
global  sphere
global  spin
global  sqrt
global  stage
global  stages
global  standard
global  state
global  static
global  status
global  step
global  stepLimit
global  stiffness
global  stop
global  str
global  strain
global  strength
global  stress

global  successful
global  suction
global  sum
global  sumD
global  sumMass
global  sumOR
global  sumSize
global  surface
global  system
global  t
global  tHat
global  tLast
global  tSys

global  tagName
global  template
global  ten
global  tensile
global  tension
global  termination
global  test
global  tf
global  than
global  that
global  the
global  theFric
global  their

global  theta
global  theta0
global  theta1
global  theta2
global  thick
global  thickness
global  this
global  three
global  thus
global  tidx
global  tidxMax
global  tight
global  timestep
global  titStr
global  title
global  tl
global  to
global  tolerance
global  too
global  top
global  total
global  tp
global  tracking

global  try
global  tt
global  ttGripBottom
global  ttGripNot
global  ttGripTop
global  ttListProps
global  ttLoadingPhase
global  ttParams
global  ttPerformStages
global  ttSetupPhase
global  tt_bea
global  tt_eRate
global  tt_loadCode
global  tt_loadFac
global  tt_loadStage
global  tt_msaMax
global  tt_msaMax0
global  tt_tg
global  twisting
global  two
global  typeid
global  types
global  udm_ListProps
global  udm_checkParams
global  udm_computeMicroStrucProps
global  udm_listMicroStrucProps
global  udm_listProps
global  unbal
global  unbonded
global  unconfined
global  undef
global  uniaxial
global  uniform
global  union
global  unit
global  until
global  up
global  update
global  updated
global  upper
global  user
global  vLimit
global  valid
global  value
global  vec2D
global  vel
global  velocity
global  vertex
global  vertexlist
global  vertices
global  vessel
global  via
global  view
global  virtual
global  vol
global  volume
global  vp
global  w
global  wGain
global  wVel
global  wall
global  wallVel
global  walls
global  was
global  wet
global  wf
global  when
global  which

global  width
global  with
global  within
global  wp0
global  wp1
global  x
global  x0
global  x1
global  x2
global  x3
global  x4
global  xCen
global  xHalfWid
global  xLt
global  xRt
global  xc
global  xcen
global  xd
global  xf
global  xhi
global  xi
global  xl
global  xlo
global  xs
global  xy
global  y
global  y0
global  y1
global  yHalfWid
global  yet
global  yhi
global  ylo
global  young_mod
global  z
global  zHalfWid
global  zero
global  zhi
global  zlo



global ft_bEuler, mv_insetDFac, _ftOneSixth
global ft_bRotationSet
global ft_bRotation
global ft_SaveState
global ft_SetTitle
global ft_valNormDist
global ft_eq
global ft_OverlapRatios
global ft_setMatBehavior
global ft_setMatBehavior
global ft_setGrainWallBehavior
global ft_SmoothGrainWallInterface
global ft_ZeroGrainDisplacement
global ft_mBonded
global ft_bNumBond
global ft_clNumBond
global ft_cGrainGrain
global ft_cGrainWall
global ft_cLinearBased
global ft_cBondable
global ft_cBondIt
global ft_cAssignLinProps
global ft_cPosPeriodic
global mv_type
global mv_emod, _mvMakeWalls, mv_wInit
global mv_mInit
global mv_mRemove
global mv_mStressZero
global mv_mStrainZero
global mv_mStress
global mv_mStrain
global mv_mPoros
global mv_wInit
global mv_wRemove
global mv_wStressZero
global mv_wStrainZero
global mv_wStress
global mv_wStrain
global mv_wPoros
global _mvMakeMeasRegions
global mv_shape
global mv_D, mv_H, mv_W
global  _ckCodeDependencies
global  _ckSize
global  ckGetSize
global  _ckSize
global  ckGetSize
global  ckInit
global  ckOn
global  ckOff  ; defined above
global  ckListData
global  ckForceUpdate
global  ckGetDFN
global  _ckUpdate
global  ckFilter
global  _ckBondBreak
global  _ckAddCrack
global  _ckName
global  _ckNameType
global  _ckNameFailMode
global  ck_nOrphans
global  ck_nFiltered
global  _ckGeom
global  _ckGeomNoContact
global  _ckGeomContact
global  _ckBallBall
global  _ckDiam
global  _ckDeformabilityRadius
global  _ckCountCrack
global  _ckResetCrackData
global  _ctCheckParams
global  ctListProps
global  ctSeatingPhase
global  ctLoadingPhase
global  ctPerformStages
global  _ctPerformStage
global  _ctEndStage
global  _ctMatTestStr
global  _ctTestStr
global  _ctApplyRadialStrain
global  _aRSdone ;{i: {mv_wex or mv_wer}, {_aRSwex0 or _aRSwer0}, _aRSeincr}
global  _ctApplyAxialStrain
global  _aASdone ;{i: mv_wea, _aASwea0, _aASeincr}
global  _ctUpdate_wsdMax
global  _aASTPPdone ;{i: mv_wsd, ct_loadFac, ct_wsdMax}
global  _ctApplyAxialPressure
global  _dcCheckParams
global  dcListProps
global  dcSetupPhase
global  dcLoadingPhase
global  dcPerformStages
global  _dcPerformStage
global  _dcEndStage
global  _dcMatTestStr
global  _dcTestStr
global  _dcApplyAxialStrain
global  _dcSetWallVel
global  _aASdone ;{i: dc_wea, _aASwea0, _aASeincr}
global  _dcUpdate_wfaMax
global  _aASTPPdone ;{i: dc_wfa, dc_loadFac, dc_wfaMax}
global  dc_wInit
global  dc_wRemove
global  dc_wForceZero
global  dc_wStrainZero
global  dc_wda
global  dc_wForce
global  dc_wStrain
global  _dcMakeWalls
global  mvMake
global  _mvMakeWalls
global  _mvMakeMeasRegions
global  _mvVolume
global  _mvCheckParams
global  mvListProps
global  mv_mInit
global  mv_mRemove
global  mv_mStressZero
global  mv_mStrainZero
global  mv_mStress
global  mv_mStrain
global  mv_mPoros
global  mv_wInit
global  mv_wRemove
global  mv_wStressZero
global  mv_wStrainZero
global  mv_wStress
global  _mvsRadForce
global  mv_wStrain
global  _mv_wAreas
global  mv_wPoros
global  mvs_on
global  mvs_off
global  _mvsCheckMeasWallOverlap
global  mvs_setBCs
global  mvs_applyConfinement
global  mvs_eqP
global  _eqPMet  ;{o: _eqP{x,y,z,r}eps; i: _eqPTol}
global  _mvsEnforceVlimit
global  _mvsSetRadVel
global  _mvsUpdateRadDiam
global  _mvsActive
global  _mvsGain
global  _mvsGainCompute
global  msOn
global  msOff
global  msForceUpdate
global  msBoxDefine
global  _msUpdate
global  _msClear
global  _msBoxGeomSetUpdate
global  _msBoxMarkGrains
global  _msGN_Make
global  _msFG_Make
global  _msFGdrawFacedGrain
global  msFG_Track
global  _msFGcoreRad
global  _msFGdrawCore
global  _msFGdrawSkirtedFaces
global  _msFGdrawSkirtedFaces2D
global  _msFGdrawSkirtedFaces3D
global  _msCB_Make
global  _msPBi_Make
global  _msPBc_Make
global  _msSBi_Make
global  _msSBiGrpName
global  _msFJi_Make
global  _msFJiDrawIntfc
global  _msFJiDrawCoordSys
global  _msFJiDrawDisc
global  _msFJiDrawDisc3D
global  _msFJiDrawDisc2D
global  _msCK_Make
global  _msCKdrawMe
global  _msCKAvgSize
global  _msCKthick
global  _msNdir
global  _msSdir
global  _msTdir
global  _msXiDir
global  _msEtaDir
global  _msPoly3
global  _msPoly4
global  _msLineA
global  _msLineB
global  _msArc
global  _msDisk
global  _msSkirt
global  _msCylinder
global  _msSphere
global  _msLineThick2D
global  _msCircle2D
global  _msGrainPieceInBox
global  _msGrainPiecePt
global  _msLocalS
global  _ftCodeDependencies
global  ft_bEuler
global  ft_bRotationSet
global  ft_bRotation
global  _ftInit
global  _ftConstants
global  _ftModulus
global  _ftAng2D
global  _ftAngMin
global  ft_SaveState
global  ft_SetTitle
global  ft_valNormDist
global  ft_eq
global  ft_OverlapRatios
global  ft_setMatBehavior
global  ft_setMatBehavior
global  ft_setGrainWallBehavior
global  ft_SmoothGrainWallInterface
global  ft_ZeroGrainDisplacement
global  ft_mBonded
global  ft_bNumBond
global  ft_clNumBond
global  ft_cGrainGrain
global  ft_cGrainWall
global  ft_cLinearBased
global  ft_cBondable
global  ft_cBondIt
global  ft_cAssignLinProps
global  bcnMeasure
global  bcnMark
global  gsdMeasure
global  gsdMark
global  gsdGetSizeOfPercentile
global  _gsdMakeGSDretained
global  _gsdBounds  ;{o: _gsdDmin, _gsdDmax}
global  _gsdMakeGSD
global  _clDiam
global  mpMake
global  mvInstallStress
global  _mvSupdateSR
global  _mvShalt ;{i: mv_Stol, mv_S{x,y,z}, mv_ms{xx,yy,zz}}
global  _mvSbondBreak
global  mpMakeFromBrick
global  _mpSetEffLinBehavior
global  _mpPackingPhase
global  _mpPackIsoState
global  _mpMaxORisSmall  ;{i: _pkORmaxLimit, _pkORcnt, _pkORupdateRate}
global  _mpMSisNearZero
global  _mpDeleteGrainsOutOfVessel
global  _mpPackBdryContract
global  _mpPackGrainScale
global  _GSPMet
global  ft_cPosPeriodic
global  _GSgetAlpha
global  _GSgetPebble
global  _GSgetRpo
global  _GSgetRpoBP
global  _GSapplyAlpha
global  _mpFinalizationPhase
global  _mpAssignSB
global  _mpAssignPB
global  _mpAssignCB
global  _mpAssignFJ
global  _mpAssignFJProps
global  _mpFJrmulReduce
global  _mpFJrmulRemoveOverlap
global  _mpFJrmulReduceAll
global  _mpFJsetMicroStruc
global  _mpAssignSBprops
global  _mpAssignSBbond
global  _mpAssignPBprops
global  _mpAssignPBbond
global  _mpAssignCBbond
global  _mpMakeGrains
global  _mpBallDistribute
global  _mpClumpDistribute
global  _mpCylRange
global  _mpCylRangeSup
global  _mpSphRange
global  _mpSphRangeSup
global  _mpSetGrainDamp
global  _mpSetGrainDensity
global  _mpCheckAllParams
global  _mpCheckCommonParams
global  _mpCheckPackingParams
global  _mpCheckLinParams
global  _mpCheckPBParams
global  _mpCheckSBParams
global  _mpCheckCBParams
global  _mpCheckFJParams
global  udm_checkParams
global  mpListMicroProps
global  mpListCommonProps
global  mpListPackingProps
global  mpListLinProps
global  mpListCBProps
global  mpListPBProps
global  mpListSBProps
global  mpListFJProps
global  udm_ListProps
global  mpListMicroStrucProps
global  udm_listMicroStrucProps
global  mpDavg
global  mpComputeMicroStrucProps
global  udm_computeMicroStrucProps
global  _ttCheckParams
global  ttListProps
global  ttSetupPhase
global  ttLoadingPhase
global  ttPerformStages
global  _ttPerformStage
global  _ttEndStage
global  _ttMatTestStr
global  _ttTestStr
global  _ttApplyAxialStrain
global  _ttSetGripVel
global  _aASdone ;{i: mv_mea, _aASmea0, _aASeincr}
global  _ttUpdate_msaMax
global  _ttUpdate_tt_bea
global  _aASTPPdone ;{i: mv_msa, tt_loadFac, tt_msaMax}
global mv_expandFac, mv_insetLFac
end
@inline

;fname: ft.fis
;
; FishTank support functions.
;
;==================================================================================================
;************************************************
; Material-Vessel Parameters:
;
;   mv_type      : vessel-type code {0,1} = {physical, periodic}
;   mv_shape     : vessel-shape code {0,1,2} = {rectangular cuboid, cylinder, sphere}
;                  [2D model: mv_shape = 0]
;   mv_{H,W,D}   : {Height, Width, Depth} = | {z,y,x }-directions, 3D model
;                                           | {y,x,NA}-directions, 2D model
;                                           | sphere diameter is mv_W
;                  Height is axial direction
;                  [2D model: mv_D is unit-thickness, not used]
;   mv_Sinstall  : stress-installation code (0/1 : do not/do install stress)
;   mv_S{x,y,z}  : installation stresses (sigma_{xx,yy,zz}, negative is compression)
;   mv_Stol      : installation-stress tolerance
;   mv_Semod     : estimate of the ensemble modulus (used to compute gain [_mvSgainPer]
;                  s.t. during each step, each del_stress is reduced by one half to insure
;                  smooth convergence to target stresses)
;   mv_SARatLimit : a-ratio limit used when installing stress in periodic assembly
;   mv_perN{x,y,z} : number of bricks in each direction {1,2,...} (perNz is NA for 2D model)
;   mv_expandFac     : expansion factor of physical vessel
;   mv_inset{L,D}Fac : inset factors of measurement regions
;                      Spanning length is mv_insetLFac times largest vessel dimenion, and
;                      measRegionDiam  is mv_insetDFac times smallest vessel dimension.
;   mv_emod      : effective modulus of physical vessel
;
;   Hidden parameters:
;     _mvCylRes : cylinder resolution (cylindrical vessel only, 3D model)
;                 Controls number of sides of circular cross section s.t. the side length is
;                 smaller than _mvCylRes times cylinder radius.
;                 Approximate mapping between resolution and number of sides:
;                   n_sides = (2.0 * math.pi) / _mvCylRes
;                   {4, 1.6}, {6, 1.2}, {8, 0.8}, {10, 0.68}, {12, 0.55}, {16, 0.4}
;     _mvSphRes : sphere resolution (spherical vessel only, 3D model)
;                 See approximate mapping for _mvCylRes
;     _mvSgainPer   : gain used when installing stress in periodic assembly (chos
;     _mvSnumBreak  : number of bonds that have broken during stress installation
;     _mvSignore    : do not enforce error condition if more than 10 bonds have broken
;
;   Set these parameters in mvSetParams in files mvParams.p{2,3}dat.
;   Material vessel is made by function mvMake.
;   Check/list all material-vessel parameters in _mvCheckParams/mvListProps.
;
;************************************************
; Material Vessel (Stress, Strain and Porosity Quantities):
;
;   Measurement-based (mv_msX, mv_meX):
;     mv_ms{xx,yy,zz,xy,xz,yz} : stress (symmetric, global system)
;                                [2D model: mv_ms{zz,xz,yz} = 0]
;     mv_me{xx,yy,zz,xy,xz,yz} : strain (symmetric, global system)
;                                [2D model: mv_me{zz,xz,yz} = 0]
;     mv_ms{a,r} : axial & radial stress
;     mv_me{a,r} : axial & radial strain
;     mv_msd     : deviator stress
;     mv_msm     : mean stress
;     mv_med     : deviator strain
;     mv_mev     : volumetric strain
;     mv_mn      : porosity
;
;     These quantities are the average values from three measurement regions (MRs).
;     These quantities are computed by mv_mStress and mv_mStrain, initialized by mv_mInit, and
;     zeroed by mv_mStressZero and mv_mStrainZero. The MRs are removed by mv_mRemove.
;
;   Wall-based (mv_wsX, mv_weX):
;     mv_wAreaMode   : wall-based areas from {0: current, 1: initial} vessel dimensions, default: 0
;     mv_ws{x,y,z}   : direct stresses (global system), force divided by wall-based areas
;                      [2D model: mv_wsz = 0]
;     mv_we{x,y,z}   : direct strains (global system)
;                      [2D model: mv_wez = 0]
;     mv_wP{x,y,z,r} : pressure on opposing walls in k-direc. (k = {x,y,z,r}), P > 0 is compression
;                      [2D model: mv_wP{z,r} = 0]
;     mv_ws{a,r} : axial & radial stress
;     mv_we{a,r} : axial & radial strain
;     mv_wsd     : deviator stress
;     mv_wsm     : mean stress
;     mv_wed     : deviator strain
;     mv_wev     : volumetric strain
;     _wA{x,y,z,r}  : wall-based areas (updated by _mv_wAreas, called only from mv_wStrain):
;                       _wA{x,y,z} is total platen area perpendicular to {x,y,z}-direc.
;                       _wAr is lateral surface area
;     _wd{x,y,z,r}  : distance btn. opposing walls in {x,y,z,r} direc.
;                     [2D model: _wd{z,r} = 0]
;     _wd{x,y,z,r}0 : initial distance btn. opposing walls in {x,y,z,r} direc.
;                     [2D model: _wd{z,r}0 = 0]
;     mv_wn      : porosity (neglects overlaps)
;
;     These quantities are computed by mv_wStress and mv_wStrain, initialized by mv_wInit, and
;     zeroed by mv_wStressZero and mv_wStrainZero (which updates the reference dimensions to
;     equal the current dimensions). The wall-based mechanism is removed by mv_wRemove.
;
;************************************************
; Servomechanism (SM)
;
;   SM Parameters:
;     mvs_BC{x,y,z,r}    : boundary-condition code (0: velocity, 1: pressure)
;                            velocityBC: velocity of wall pair is equal & opposite and
;                                        velocity of cylindrical-wall vertices is radial
;                                        (with positive velocity indicating opening motion)
;                            pressureBC: velocity controlled by SCM to maintain pressure
;                          [2D model: mvs_BC{z,r} not used]
;     mvs_BC{x,y,z,r}Val : boundary-condition value (velocity or pressure, based on BC code)
;                          [2D model: mvs_BC{z,r}Val not used]
;     mvs_gainUpdateRate : servo gain update rate (number of cycles)
;     mvs_vLimit         : limiting velocity (|v| <= vLimit, vLimit > 0)
;                            Always enforced, even for velocityBC.
;                            For pressureBC, used if gain is not adequate (KnSum is zero or
;                            gain gives excessive velocity).
;
;   When the SM is on, it enforces the BCs during cycling.
;   The SM is turned on by mvs_on, and turned off by mvs_off.
;   Each direction has its own servo gain, which is updated when mvs_on is called,
;   and thereafter at the specified rate (mvs_gainUpdateRate).
;   The BCs are set by mvs_setBCs, which may be called multiple times.
;   Static-equilibrium is enforced by mvs_eqP() and ft_eq().
;   Confinement application is provided by mvs_applyConfinement().
;   Radial velocity of cylinder- and sphere-wall vertices is stored in _mvsRadVel, and
;   diameter of cylinder- and sphere-wall is updated by _mvsUpdateRadDiam.
;
;************************************************
; Check/list all material-related parameters in _mpCheckAllParams/mpListMicroProps.
; -----------------------------------------------
; Common Parameters:
;
;   cm_matName      : material name (for model title)
;   cm_matNameSAV   : material name (for SAV file names)
;   cm_matType      : material-type code [0,5] = {linear,
;                                                 contact-bonded, parallel-bonded,
;                                                 soft-bonded, flat-jointed,
;                                                 user-defined}
;   cm_localDampFac : local-damping factor
;   cm_densityCode  : density code (Crho, 0: grain, 1: bulk)
;   cm_densityVal   : density value (rhoV, set density of each grain equal to:
;                      rhoV (if Crho = 0)
;                      rhoV * Vv / Vg, where Vv is volume of vessel, and
;                                            Vg is total volume of grains)
;
;   Grain shape & size distribution group:
;     cm_shape       : grain-shape code {0,1} = {all balls, all clumps}
;     cm_nSD         : number of size distributions
;     cm_typeSD(nSD) : size-distribution type {0,1} = {uniform, gaussian}
;     cm_ctName(nSD) : clump-template name (cm_shape = 1)
;     cm_Dlo(nSD)    : diameter range (lower)
;     cm_Dup(nSD)    : diameter range (upper)
;     cm_Vfrac(nSD)  : volume fraction
;     cm_Dmult       : diameter multiplier (shifts the size distributions)
;
;   Set these parameters in mpSetCommonParams in files mpParams.p{2,3}dat.
;************************************************
; Packing Parameters:
;
;   pk_seed      : seed of random-number generator (affects packing)
;   pk_Pm        : material pressure
;   pk_PTol      : pressure tolerance
;   pk_ARatLimit : equil-ratio limit (parameter of ft_eq)
;   pk_stepLimit : step limit (parameter of ft_eq)
;   pk_procCode  : packing-procedure code (0: boundary contraction, 1: grain scaling)
;   pk_nc        : grain-cloud porosity
;   Boundary-contraction group (pk_procCode = 0):
;     pk_fricCA : material friction coef. during confinement application (CA)
;     pk_vLimit : servo velocity limit during CA (see mvs_vLimit)
;
;   Hidden parameters:
;     _pkORmaxLimit   - overlap-ratio maximum limit (used by _mpPackIsoState)
;     _pkORupdateRate - overlap-ratio update rate (number of cycles), uses _pkORcnt
;     _pkSavPreFinal  - create save file of state just before finalization
;                       {0,1}={yes,no}
;
;   Set these parameters in mpSetPackingParams in files mpParams.p{2,3}dat.
;************************************************
; Linear Material Parameters:
;
;   Common group (see above)
;   Packing group (see above)
;   Linear material group:
;     lnm_emod : effective modulus
;     lnm_krat : stiffness ratio
;     lnm_fric : friction coefficient
;
;   Set these parameters in mpSetLinParams in files mpParams.p{2,3}dat.
;************************************************
; Contact-Bonded Material Parameters:
;
;   Common group (see above)
;   Packing group (see above)
;   Contact-bonded material group:
;     Linear group:
;       cbm_emod : effective modulus
;       cbm_krat : stiffness ratio
;       cbm_fric : friction coefficient
;
;     Contact-bond group:
;       cbm_igap      : installation gap
;       cbm_tens_m    : tensile-strength distribution [stress] (mean)
;       cbm_tens_sd   : tensile-strength distribution [stress] (standard deviation)
;       cbm_shears_m  : shear-strength   distribution [stress] (mean)
;       cbm_shears_sd : shear-strength   distribution [stress] (standard deviation)
;
;   Linear material group:
;     lnm_emod : effective modulus
;     lnm_krat : stiffness ratio
;     lnm_fric : friction coefficient
;
;   Set these parameters in mpSetCBParams in files mpParams.p{2,3}dat.
;************************************************
; Parallel-Bonded Material Parameters:
;
;   Common group (see above)
;   Packing group (see above)
;   Parallel-bonded material group:
;     Linear group:
;       pbm_emod : effective modulus
;       pbm_krat : stiffness ratio
;       pbm_fric : friction coefficient
;
;     Parallel-bond group:
;       pbm_igap   : installation gap
;       pbm_rmul   : radius multiplier
;       pbm_bemod  : bond effective modulus
;       pbm_bkrat  : bond stiffness ratio
;       pbm_mcf    : moment-contribution factor
;       pbm_ten_m  : tensile-strength distribution (mean)
;       pbm_ten_sd : tensile-strength distribution (standard deviation)
;       pbm_coh_m  : cohesion distribution (mean)
;       pbm_coh_sd : cohesion distribution (standard deviation)
;       pbm_fa     : friction angle (degrees)
;
;   Linear material group:
;     lnm_emod : effective modulus
;     lnm_krat : stiffness ratio
;     lnm_fric : friction coefficient
;
;   Set these parameters in mpSetPBParams in files mpParams.p{2,3}dat.
;************************************************
; Soft-Bonded Material Parameters:
;
;   Common group (see above)
;   Packing group (see above)
;   Soft-bonded material group:
;     sbm_igap   : installation gap
;     sbm_rmul   : radius multiplier
;     sbm_bemod  : effective modulus
;     sbm_bkrat  : stiffness ratio
;     sbm_mcf    : moment-contribution factor
;     sbm_ten_m  : tensile-strength distribution (mean)
;     sbm_ten_sd : tensile-strength distribution (standard deviation)
;     sbm_coh_m  : cohesion distribution (mean)
;     sbm_coh_sd : cohesion distribution (standard deviation)
;     sbm_fa     : friction angle (degrees)
;     sbm_soft   : softening factor
;     sbm_cut    : strength-reduction factor
;     sbm_fric   : friction coefficient (when unbonded)
;     sbm_bmul   : bending-friction multiplier (when unbonded)
;     sbm_tmul   : twisting-friction multiplier (when unbonded)
;
;   Linear material group:
;     lnm_emod : effective modulus
;     lnm_krat : stiffness ratio
;     lnm_fric : friction coefficient
;
;   Set these parameters in mpSetSBParams in files mpParams.p{2,3}dat.
;************************************************
; Flat-Jointed Material Parameters:
;
;   Common group (see above)
;   Packing group (see above)
;   Flat-jointed material group:
;     fjm_trackMS  : microstructure-tracking flag
;     fjm_igap     : installation gap
;     fjm_B_frac   : bonded fraction
;     fjm_G_frac   : gapped fraction
;     fjm_S_frac   : slit fraction (derived from fjm_B_frac and fjm_G_frac)
;     fjm_G_m      : initial surface-gap distribution (mean)
;     fjm_G_sd     : initial surface-gap distribution (standard deviation)
;     fjm_Nr       : elements in radial direc.
;                    [2D model: total number of elements]
;     fjm_Nal      : elements in circumferential direc. (3D only)
;     fjm_rmulCode : radius-multiplier code (0: lambda constant (no valid check)
;                                            1: valid  via lambda non-uniform reduce
;                                            2: valid* via lambda uniform reduce)
;     fjm_rmulVal  : radius-multiplier value (fixed,    rmulCode = 0
;                                             starting, rmulCode = {1,2})
;     fjm_emod     : effective modulus
;     fjm_krat     : stiffness ratio
;     fjm_fric     : friction coefficient
;     fjm_ten_m    : tensile-strength distribution (mean)
;     fjm_ten_sd   : tensile-strength distribution (standard deviation)
;     fjm_coh_m    : cohesion distribution (mean)
;     fjm_coh_sd   : cohesion distribution (standard deviation)
;     fjm_fa       : friction angle (degrees)
;
;   Linear material group:
;     lnm_emod : effective modulus
;     lnm_krat : stiffness ratio
;     lnm_fric : friction coefficient
;
;   Set these parameters in mpSetFJParams in files mpParams.p{2,3}dat.
;
;************************************************
fish define mvMake
; Make the material vessel.
;
; IN:  Material-Vessel Parameters
; OUT: mvWp{0,1}{x,y,z} : six axis-aligned wall pointers s.t. {0,1} = {-,+}
;                                                             {x,y,z} = axis direction
;                         [2D model: mvWp{0,1}z not used]
;      mvWpCyl          : one z-aligned cylinder-wall pointer
;                         [2D model: mvWpCyl not used]
;      mvWpSph          : one sphere-wall pointer
;      mvMp{1,2,3} : three measurement-region (MR) pointers
;                    The MRs are placed symmetrically along the axis of the largest
;                    vessel dimension (with a spanning length of mv_insetLFac times the largest
;                    vessel dimension, and with a diameter of mv_insetDFac times the smallest
;                    vessel dimension).
;                    The MR-1 is at the origin, and MR-{2,3} are
;                    positioned along the axis as:
;                        2     1     3
;                      --*-----*-----*-- ===> positive axis direc.
;      _mvMpAxLen       : axial length spanned by measurement regions
;      _mvMpRadLen{X,Y} : radial lengths in x & y direcs. spanned by measurement regions
;
  io.out('## mvMake (entering).')
  ft_SetTitle( 'Making material vessel...' )
  ;
  local lenFac
  if mv_type == 0 then
    lenFac = 1.0
  else ; mv_type == 1
    lenFac = 0.5
  end_if
  if global.dim == 3 then
    command
      model domain extent [-lenFac*mv_D] [lenFac*mv_D] ...
                          [-lenFac*mv_W] [lenFac*mv_W] ...
                          [-lenFac*mv_H] [lenFac*mv_H]
    end_command
    if mv_type == 0 then
      command
        model domain condition stop stop stop
      end_command
    else ; mv_type == 1
      command
        model domain condition periodic periodic periodic
      end_command
    end_if
  else ; 2D model
    command
      model domain extent [-lenFac*mv_W] [lenFac*mv_W] ...
                          [-lenFac*mv_H] [lenFac*mv_H]
    end_command
    if mv_type == 0 then
      command
        model domain condition stop stop
      end_command
    else ; mv_type == 1
      command
        model domain condition periodic periodic
      end_command
    end_if
  end_if
  ;
  if mv_type == 0 then
    ft_setGrainWallBehavior( 'existing', 0.0, mv_emod, 0.0, 0.0, 'linear' )
    ft_setGrainWallBehavior( 'future',   0.0, mv_emod, 0.0, 0.0, 'linear' )
    _mvMakeWalls
    mv_wInit
  end_if
  _mvMakeMeasRegions
  mv_mInit
  ;
  ; Monitor measure- and wall-based mean stress.
  command
    history interval 20
    fish history name '1' @mv_msm
    fish history name '2' @mv_wsm
    fish history name '3' @mv_mn
    fish history name '4' @mv_wn
  end_command
  if mv_type == 1 then
    mv_wsm = 0.0
    mv_wn = 0.0
  end_if
  io.out('## mvMake (exiting).')
end
;------------------------------------------------
fish define _mvMakeWalls
  if mv_shape == 0 then ; rectangular cuboid
    if global.dim == 3 then
      command
        wall generate id 1 name 'mv' box [-0.5*mv_D*mv_expandFac] [0.5*mv_D*mv_expandFac] ...
                                         [-0.5*mv_W*mv_expandFac] [0.5*mv_W*mv_expandFac] ...
                                         [-0.5*mv_H*mv_expandFac] [0.5*mv_H*mv_expandFac]
      end_command
      mvWp0x = wall.find(3)
      mvWp1x = wall.find(4)
      mvWp0y = wall.find(5)
      mvWp1y = wall.find(6)
      mvWp0z = wall.find(1)
      mvWp1z = wall.find(2)
      ; Move walls to conform to material vessel dimensions.
      wall.pos(mvWp0x, 1) = -0.5*mv_D
      wall.pos(mvWp1x, 1) =  0.5*mv_D
      wall.pos(mvWp0y, 2) = -0.5*mv_W
      wall.pos(mvWp1y, 2) =  0.5*mv_W
      wall.pos(mvWp0z, 3) = -0.5*mv_H
      wall.pos(mvWp1z, 3) =  0.5*mv_H
    else ; 2D model
      command
        wall generate id 1 name 'mv' box [-0.5*mv_W*mv_expandFac] [0.5*mv_W*mv_expandFac] ...
                                         [-0.5*mv_H*mv_expandFac] [0.5*mv_H*mv_expandFac]
      end_command
      mvWp0x = wall.find(4)
      mvWp1x = wall.find(2)
      mvWp0y = wall.find(1)
      mvWp1y = wall.find(3)
      ; Move walls to conform to material vessel dimensions.
      wall.pos(mvWp0x, 1) = -0.5*mv_W
      wall.pos(mvWp1x, 1) =  0.5*mv_W
      wall.pos(mvWp0y, 2) = -0.5*mv_H
      wall.pos(mvWp1y, 2) =  0.5*mv_H
    end_if
  else if mv_shape == 1 then ; cylinder
    local cylRad = 0.5*mv_W
    local cylRadEx = cylRad*mv_expandFac
    command
      wall generate id 1 name 'mvCyl' cylinder axis [vector(0.0, 0.0, 1.0)]                    ...
                                               base [vector(0.0, 0.0, -0.5*mv_H*mv_expandFac)] ...
                                               height [mv_H*mv_expandFac]                      ...
                                               radius [cylRad]                                 ...
                                               cap no no                                       ...
                                               resolution [_mvCylRes]
      wall generate id 2 name 'mvBottom' polygon [vector(-cylRadEx,-cylRadEx,-0.5*mv_H)] ...
                                                 [vector(-cylRadEx, cylRadEx,-0.5*mv_H)] ...
                                                 [vector( cylRadEx, cylRadEx,-0.5*mv_H)] ...
                                                 [vector( cylRadEx,-cylRadEx,-0.5*mv_H)] ...
                                                 make-planar
      wall generate id 3 name 'mvTop'    polygon [vector(-cylRadEx,-cylRadEx, 0.5*mv_H)] ...
                                                 [vector(-cylRadEx, cylRadEx, 0.5*mv_H)] ...
                                                 [vector( cylRadEx, cylRadEx, 0.5*mv_H)] ...
                                                 [vector( cylRadEx,-cylRadEx, 0.5*mv_H)] ...
                                                 make-planar
    end_command
    mvWpCyl = wall.find(1)
    mvWp0z  = wall.find(2)
    mvWp1z  = wall.find(3)
  else ; mv_shape = 2 (sphere)
    local sphRad = 0.5*mv_H
    command
      wall generate id 1 name 'mvSphere' sphere position [vector(0.0, 0.0, 0.0)] ...
                                                radius [sphRad]                  ...
                                                resolution [_mvSphRes]
    end_command
    mvWpSph = wall.find(1)
  end_if
end
;------------------------------------------------
fish define _mvMakeMeasRegions
; IN: mv_inset{L,D}Fac
; OUT: mvMp{1,2,3}, _mvMpAxLen, _mvMpRadLen{X,Y} : see description in mvMake.
;
  local _Lmax = math.max(  mv_H, mv_W )
  local _Lmin = math.min(  mv_H, mv_W )
  if global.dim == 3 then
    _Lmax = math.max( _Lmax, mv_D )
    _Lmin = math.min( _Lmin, mv_D )
  end_if
  local _mvMpLength = mv_insetLFac * _Lmax
  local _mvMpDiam   = mv_insetDFac * _Lmin
  ;
  ; 3D model: mv_shape=0: {H,W,D}  : {z,y,x}
  ;           mv_shape=1: {H, W=D} : {z, y=x}
  local _iHatMax
  if global.dim == 3 then
    if mv_H >= mv_W then
      if mv_H >= mv_D then ; maxDir is z
        _iHatMax = vector(0.0, 0.0, 1.0)
        _mvMpAxLen   = _mvMpLength
        _mvMpRadLenX = _mvMpDiam
        _mvMpRadLenY = _mvMpDiam
      end_if
    end_if
    if mv_W >= mv_D then
      if mv_W >= mv_H then ; maxDir is y
        _iHatMax = vector(0.0, 1.0, 0.0)
        _mvMpAxLen   = _mvMpDiam
        _mvMpRadLenX = _mvMpDiam
        _mvMpRadLenY = _mvMpLength
      end_if
    end_if
    if mv_D >= mv_H then
      if mv_D >= mv_W then ; maxDir is x
        _iHatMax = vector(1.0, 0.0, 0.0)
        _mvMpAxLen   = _mvMpDiam
        _mvMpRadLenX = _mvMpLength
        _mvMpRadLenY = _mvMpDiam
      end_if
    end_if
  else ; 2D model
    if mv_H >= mv_W then ; maxDir is y
      _iHatMax = vector(0.0, 1.0)
      _mvMpAxLen   = _mvMpLength
      _mvMpRadLenX = _mvMpDiam
    else                 ; maxDir is x
      _iHatMax = vector(1.0, 0.0)
      _mvMpAxLen   = _mvMpDiam
      _mvMpRadLenX = _mvMpLength
    end_if
  end_if
  ;
  local _mRad = 0.5 * _mvMpDiam
  local _mPos
  if global.dim == 3 then
    _mPos = vector(0.0, 0.0, 0.0)
  else ; 2D model
    _mPos = vector(0.0, 0.0)
  end_if
  command
    measure create id 1 radius @_mRad position @_mPos
  end_command
  local _mFac = (0.5 * _mvMpLength) - _mRad
  _mPos = -_mFac * _iHatMax
  command
    measure create id 2 radius @_mRad position @_mPos
  end_command
  _mPos = _mFac * _iHatMax
  command
    measure create id 3 radius @_mRad position @_mPos
  end_command
  ;
  mvMp1 = measure.find(1)
  mvMp2 = measure.find(2)
  mvMp3 = measure.find(3)
end
;------------------------------------------------
fish define _mvVolume( initDim )
; Return volume of material vessel. If [initDim] = true, then use initial dimensions,
; otherwise, use current dimensions.
;
; IN: mv_shape, mv_{H,W,D}
;
  if initDim then
    if mv_shape == 0 then
      if global.dim == 3 then
        _mvVolume = mv_H * mv_W * mv_D
      else ; 2D model
        _mvVolume = mv_H * mv_W
      end_if
    else if mv_shape == 1
      _mvVolume = (0.25 * math.pi * mv_W * mv_W) * mv_H
    else ; mv_shape == 2
      _mvVolume = _ftOneSixth * math.pi * mv_H * mv_H * mv_H
    end_if
  else ; initDim = false, use current dimensions
    local _wAreaMode = mv_wAreaMode
    mv_wAreaMode = 0
    _mv_wAreas
      if mv_shape == 0 then
        if global.dim == 3 then
          _mvVolume = _wdx * _wdy * _wdz
        else ; 2D model
          _mvVolume = _wdx * _wdy
        end_if
      else if mv_shape == 1
        _mvVolume = (0.25 * math.pi * _wdr * _wdr) * _wdz
      else ; mv_shape == 2
        _mvVolume = _ftOneSixth * math.pi * _wdr * _wdr * _wdr
      end_if
    mv_wAreaMode = _wAreaMode
    _mv_wAreas
  end_if
end
;------------------------------------------------
fish define _mvCheckParams
  if (mv_type < 0) | (mv_type > 1) then
    system.error = 'mv_type must be {0,1}.'
  end_if
  ;
  if global.dim == 3 then
    if (mv_shape < 0) | (mv_shape > 2) then
      system.error = 'mv_shape must be {0,1,2}.'
    end_if
  else ; 2D model
    mv_shape = 0
  end_if
  ;
  if (mv_type == 1) & (mv_shape # 0) then
    system.error = 'Periodic cell must be a rectangular cuboid (mv_shape = 0).'
  end_if
  ;
  if mv_shape == 1 then
    mv_D = mv_W  ; mv_W defines cylinder diameter, but mv_D is used in making measure regions and
                 ; generating grain cloud within the box of the {ball,clump} distribute command.
    if _mvCylRes == 0 then ; default
      _mvCylRes = 0.55 ; 12-sided polygon
    end_if
  else if mv_shape == 2 then
    mv_W = mv_H
    mv_D = mv_H
    if _mvSphRes == 0 then ; default
      _mvSphRes = 0.55 ; equator is 12-sided polygon
    end_if
  end_if
  ;
  if mv_H == 0 then ; default
    system.error = 'mv_H must be specified.'
  else
    if mv_H <= 0.0 then
      system.error = 'mv_H must be greater than zero.'
    end_if
  end_if
  if mv_W == 0 then ; default
    system.error = 'mv_W must be specified.'
  else
    if mv_W <= 0.0 then
      system.error = 'mv_W must be greater than zero.'
    end_if
  end_if
  if mv_shape == 0 then
    if global.dim == 3 then
      if mv_D == 0 then ; default
        system.error = 'mv_D must be specified.'
      else
        if mv_D <= 0.0 then
          system.error = 'mv_D must be greater than zero.'
        end_if
      end_if
    else ; 2D model
      mv_D = 1.0 ; unit-thickness disks, ALWAYS!
    end_if
  end_if
  ;
  ; mv_Sinstall has default of zero. No checking for mv_S{x,y,z} because real numbers.
  if mv_type == 1 then
    if (mv_Sinstall < 0) | (ms_Sinstall > 1)
      system.error = 'mv_Sinstall must be {0,1}.'
    end_if
    if mv_Stol == 0 then ; default
      mv_Stol = 1e-2
    else
      if mv_Stol <= 0.0 then
        system.error = 'mv_Stol must be greater than or equal to zero.'
      end_if
    end_if
    if mv_Semod == 0 then ; default
      system.error = 'mv_Semod must be specified.'
    else
      if mv_Semod <= 0.0 then
        system.error = 'mv_Semod must be greater than zero.'
      end_if
    end_if
    if mv_SARatLimit == 0 then ; default
      mv_SARatLimit = 1e-5
    else
      if mv_SARatLimit <= 0.0 then
        system.error = 'mv_SARatLimit must be greater than zero.'
      end_if
    end_if
    if mv_perNx == 0 then ; default
      mv_perNx = 1
    else
      if mv_perNx < 1 then
        system.error = 'mv_perNx must be in {1,2,...}.'
      end_if
    end_if
    if mv_perNy == 0 then ; default
      mv_perNy = 1
    else
      if mv_perNy < 1 then
        system.error = 'mv_perNy must be in {1,2,...}.'
      end_if
    end_if
    if global.dim == 3 then
      if mv_perNz == 0 then ; default
        mv_perNz = 1
      else
        if mv_perNz < 1 then
          system.error = 'mv_perNz must be in {1,2,...}.'
        end_if
      end_if
    end_if
  end_if
  ;
  if mv_expandFac == 0 then ; default
    mv_expandFac = 1.2
  else
    if mv_expandFac < 1.0 then
      system.error = 'mv_expandFac must be greater than or equal to one.'
    end_if
  end_if
  ;
  if mv_type == 0 then
    if mv_emod == 0 then ; default
      system.error = 'mv_emod must be specified.'
    else
      if mv_emod <= 0.0 then
        system.error = 'mv_emod must be greater than zero.'
      end_if
    end_if
  end_if
  ;
  if mv_insetLFac == 0 then ; default
    mv_insetLFac = 0.8
  else
    if mv_insetLFac <= 0.0 then
      system.error = 'mv_insetLFac must be greater than zero.'
    end_if
    if mv_insetLFac > 1.0 then
      system.error = 'mv_insetLFac must be less than or equal to one.'
    end_if
  end_if
  ;
  if mv_insetDFac == 0 then ; default
    mv_insetDFac = 0.8
  else
    if mv_insetDFac <= 0.0 then
      system.error = 'mv_insetDFac must be greater than zero.'
    end_if
    if mv_insetDFac > 1.0 then
      system.error = 'mv_insetDFac must be less than or equal to one.'
    end_if
  end_if
end
;------------------------------------------------
fish define mvListProps
  io.out('## Material-Vessel Properties:')
  ;
  local _str = '     mv_type: '+string(mv_type)
  case_of mv_type
      system.error = 'mv_type is not {0,1}.'
    case 0
      _str = _str + ' (physical)'
    case 1
      _str = _str + ' (periodic)'
  end_case
  io.out(_str)
  ;
  _str = '     mv_shape: '+string(mv_shape)
  case_of mv_shape
      system.error = 'mv_shape is not {0,1,2}.'
    case 0
      _str = _str + ' (rectangular cuboid)'
    case 1
      _str = _str + ' (cylinder, _mvCylRes: ' + string(_mvCylRes) + ')'
    case 2
      _str = _str + ' (sphere, _mvSphRes: ' + string(_mvSphRes) + ')'
  end_case
  io.out(_str)
  ;
  if global.dim == 3 then
    if mv_shape == 0 then
      _str = '     {mv_H, _wdz} (height {initial, current}, aligned with z-axis): {'
      _str = _str + string(mv_H) + ',' + string(_wdz) + '}'
      io.out( _str )
      _str = '     {mv_W, _wdy} ( width {initial, current}, aligned with y-axis): {'
      _str = _str + string(mv_W) + ',' + string(_wdy) + '}'
      io.out( _str )
      _str = '     {mv_D, _wdx} ( depth {initial, current}, aligned with x-axis): {'
      _str = _str + string(mv_D) + ',' + string(_wdx) + '}'
      io.out( _str )
    else if mv_shape == 1 then
      _str = '     {mv_H, _wdz} (height {initial, current}, aligned with z-axis): {'
      _str = _str + string(mv_H) + ',' + string(_wdz) + '}'
      io.out( _str )
      _str = '     {mv_W, _wdr} (diameter {initial, current},  lies in xy-plane): {'
      _str = _str + string(mv_W) + ',' + string(_wdr) + '}'
      io.out( _str )
    else ; mv_shape == 2
      _str = '     {mv_H, _wdr} (diameter {initial, current}): {'
      _str = _str + string(mv_H) + ',' + string(_wdr) + '}'
      io.out( _str )
    end_if
  else ; 2D model
    _str = '     {mv_H, _wdy} (height {initial, current}, aligned with y-axis): {'
    _str = _str + string(mv_H) + ',' + string(_wdy) + '}'
    io.out( _str )
    _str = '     {mv_W, _wdx} ( width {initial, current}, aligned with x-axis): {'
    _str = _str + string(mv_W) + ',' + string(_wdx) + '}'
    io.out( _str )
    io.out('     mv_D (depth,  aligned with z-axis): ' + string(mv_D))
    io.out('       [2D model: unit-thickness disks, thus mv_D is always one.]')
  end_if
  if mv_type == 1 then
    io.out('     mv_Sinstall: ' + string(mv_sInstall))
    io.out('     mv_Sx: ' + string(mv_Sx))
    io.out('     mv_Sy: ' + string(mv_Sy))
    if global.dim == 3 then
      io.out('     mv_Sz: ' + string(mv_Sz))
    end_if
    io.out('     mv_Stol: ' + string(mv_Stol))
    io.out('     mv_Semod: ' + string(mv_Semod))
    io.out('     mv_SARatLimit: ' + string(mv_SARatLimit))
    io.out('     mv_perNx: ' + string(mv_perNx))
    io.out('     mv_perNy: ' + string(mv_perNy))
    if global.dim == 3 then
      io.out('     mv_perNz: ' + string(mv_perNz))
    end_if
  end_if
  if mv_type == 0 then
    io.out('     mv_expandFac: ' + string(mv_expandFac))
    io.out('     mv_emod (effective modulus): ' + string(mv_emod))
  end_if
  io.out('     mv_insetLFac (measurement region spanning-length factor): ' + string(mv_insetLFac))
  io.out('     mv_insetDFac (measurement region diameter factor): ' + string(mv_insetDFac))
end
;************************************************
fish define mv_mInit
  mv_mStressZero
  mv_mStress
  mv_mStrainZero
  mv_mStrain
  mv_mPoros
  command
    fish callback add @mv_mStress 42.1   ; after FDLaw (40.1 is not allowed)
    fish callback add @mv_mStrain 10.10  ; after EOMs
    fish callback add @mv_mPoros  10.10  ; after EOMs
  end_command
end
;------------------------------------------------
fish define mv_mRemove
  mv_mStressZero
  mv_mStrainZero
  mv_mn = 0.0
  command
    fish callback remove @mv_mStress 42.1
    fish callback remove @mv_mStrain 10.10
    fish callback remove @mv_mPoros  10.10
  end_command
  measure.delete( mvMp1 )
  measure.delete( mvMp2 )
  measure.delete( mvMp3 )
end
;------------------------------------------------
fish define mv_mStressZero
  mv_msxx = 0.0
  mv_msyy = 0.0
  mv_mszz = 0.0
  mv_msxy = 0.0
  mv_msxz = 0.0
  mv_msyz = 0.0
  ;
  mv_msa = 0.0
  mv_msr = 0.0
  mv_msd = 0.0
  mv_msm = 0.0
end
;------------------------------------------------
fish define mv_mStrainZero
  mv_mexx = 0.0
  mv_meyy = 0.0
  mv_mezz = 0.0
  mv_mexy = 0.0
  mv_mexz = 0.0
  mv_meyz = 0.0
  ;
  mv_mea = 0.0
  mv_mer = 0.0
  mv_med = 0.0
  mv_mev = 0.0
end
;------------------------------------------------
fish define mv_mStress
; Update the material vessel measurement-based stress quantities.
; IN:  mvMp{1,2,3}
; OUT: mv_msX      (defined above)
;
  local myTen1 = measure.stress(mvMp1) ; stress tensor (has been made symmetric)
  local myTen2 = measure.stress(mvMp2)
  local myTen3 = measure.stress(mvMp3)
  mv_msxx = _ftOneThird * ( myTen1(1,1) + myTen2(1,1) + myTen3(1,1) )
  mv_msyy = _ftOneThird * ( myTen1(2,2) + myTen2(2,2) + myTen3(2,2) )
  mv_msxy = _ftOneThird * ( myTen1(1,2) + myTen2(1,2) + myTen3(1,2) )
  if global.dim == 3 then
    mv_mszz = _ftOneThird * ( myTen1(3,3) + myTen2(3,3) + myTen3(3,3) )
    mv_msxz = _ftOneThird * ( myTen1(1,3) + myTen2(1,3) + myTen3(1,3) )
    mv_msyz = _ftOneThird * ( myTen1(2,3) + myTen2(2,3) + myTen3(2,3) )
  end_if
  ;
  if global.dim == 3 then
    mv_msa = mv_mszz
    mv_msr = 0.5 * (mv_msxx + mv_msyy)
    mv_msm = _ftOneThird * (mv_msa + 2.0*mv_msr)
  else ; 2D model
    mv_msa = mv_msyy
    mv_msr = mv_msxx
    mv_msm = 0.5 * (mv_msa + mv_msr)
  end_if
  mv_msd = mv_msa - mv_msr
end
;------------------------------------------------
fish define mv_mStrain
; Update the material vessel measurement-based strain quantities.
; IN:  mvMp{1,2,3}
; OUT: mv_meX      (defined above)
;
  local myTen1 = measure.strain.rate(mvMp1) ; strain-rate tensor (symmetric portion of VGT)
  local myTen2 = measure.strain.rate(mvMp2)
  local myTen3 = measure.strain.rate(mvMp3)
  mv_mexx = mv_mexx + _ftOneThird * ( myTen1(1,1) + myTen2(1,1) + myTen3(1,1) ) * mech.timestep
  mv_meyy = mv_meyy + _ftOneThird * ( myTen1(2,2) + myTen2(2,2) + myTen3(2,2) ) * mech.timestep
  mv_mexy = mv_mexy + _ftOneThird * ( myTen1(1,2) + myTen2(1,2) + myTen3(1,2) ) * mech.timestep
  if global.dim == 3 then
    mv_mezz = mv_mezz + _ftOneThird * ( myTen1(3,3) + myTen2(3,3) + myTen3(3,3) ) * mech.timestep
    mv_mexz = mv_mexz + _ftOneThird * ( myTen1(1,3) + myTen2(1,3) + myTen3(1,3) ) * mech.timestep
    mv_meyz = mv_meyz + _ftOneThird * ( myTen1(2,3) + myTen2(2,3) + myTen3(2,3) ) * mech.timestep
  end_if
  ;
  if global.dim == 3 then
    mv_mea = mv_mezz
    mv_mer = 0.5*( mv_mexx + mv_meyy )
    mv_mev = mv_mea + 2.0*mv_mer
  else ; 2D model
    mv_mea = mv_meyy
    mv_mer = mv_mexx
    mv_mev = mv_mea + mv_mer
  end_if
  mv_med = mv_mea - mv_mer
end
;------------------------------------------------
fish define mv_mPoros
; Update the material vessel measurement-based porosity.
; IN:  mvMp{1,2,3}
; OUT: mv_mn (defined above)
;
  mv_mn = _ftOneThird * (   measure.porosity(mvMp1) ...
                          + measure.porosity(mvMp2) ...
                          + measure.porosity(mvMp3)     )
end
;------------------------------------------------
fish define mv_wInit
  if global.dim == 3 then
    _wdx = mv_D
    _wdy = mv_W
    _wdz = mv_H
    _wdr = mv_W
  else ; 2D model
    _wdx = mv_W
    _wdy = mv_H
  end_if
  ;
  mv_wStrainZero
  mv_wStrain
  mv_wStressZero
  mv_wStress
  mv_wPoros
  command
    fish callback add @mv_wStress 42.1   ; after FDLaw (40.1 is not allowed)
    fish callback add @mv_wStrain 10.10  ; after EOMs
    fish callback add @mv_wPoros  10.10  ; after EOMs
  end_command
end
;------------------------------------------------
fish define mv_wRemove
  mv_wStrainZero
  mv_wStressZero
  command
    fish callback remove @mv_wStress 42.1
    fish callback remove @mv_wStrain 10.10
    fish callback remove @mv_wPoros  10.10
  end_command
  if mv_shape == 0 then
    wall.delete( mvWp0x )
    wall.delete( mvWp1x )
    wall.delete( mvWp0y )
    wall.delete( mvWp1y )
    if global.dim == 3 then
      wall.delete( mvWp0z )
      wall.delete( mvWp1z )
    end_if
  else if mv_shape == 1
    wall.delete( mvWp0z )
    wall.delete( mvWp1z )
    wall.delete( mvWpCyl )
  else ; mv_shape == 2
    wall.delete( mvWpSph )
  end_if
end
;------------------------------------------------
fish define mv_wStressZero
  mv_wsx = 0.0
  mv_wsy = 0.0
  mv_wsz = 0.0
  mv_wsr = 0.0
  mv_wPx = 0.0
  mv_wPy = 0.0
  mv_wPz = 0.0
  mv_wPr = 0.0
  mv_wsa = 0.0
  mv_wsr = 0.0
  mv_wsd = 0.0
  mv_wsm = 0.0
end
;------------------------------------------------
fish define mv_wStrainZero
  ; Establish reference dimensions: set initial
  _wdx0 = _wdx
  _wdy0 = _wdy
  if global.dim == 3 then
    _wdz0 = _wdz
    _wdr0 = _wdr
  end_if
  ; Zero the strain quantities
  mv_wex = 0.0
  mv_wey = 0.0
  mv_wez = 0.0
  mv_wea = 0.0
  mv_wer = 0.0
  mv_wed = 0.0
  mv_wev = 0.0
end
;------------------------------------------------
fish define mv_wStress
; Update the material vessel wall-based stress quantities.
;
; IN:  mvWp{0,1}{x,y,z}, mvWpCyl, mvWpSph, _wA{x,y,z,r}, mv_shape
; OUT: mv_wsX, mv_wPX
;
  if mv_shape == 0 then
    if global.dim == 3 then
      mv_wsx = 0.5*( wall.force.contact(mvWp0x, 1) - wall.force.contact(mvWp1x, 1) ) / _wAx
      mv_wsy = 0.5*( wall.force.contact(mvWp0y, 2) - wall.force.contact(mvWp1y, 2) ) / _wAy
      mv_wsz = 0.5*( wall.force.contact(mvWp0z, 3) - wall.force.contact(mvWp1z, 3) ) / _wAz
      mv_wPz = -mv_wsz
    else ; 2D model
      mv_wsx = 0.5*( wall.force.contact(mvWp0x, 1) - wall.force.contact(mvWp1x, 1) ) / _wAx
      mv_wsy = 0.5*( wall.force.contact(mvWp0y, 2) - wall.force.contact(mvWp1y, 2) ) / _wAy
    end_if
    mv_wPx = -mv_wsx
    mv_wPy = -mv_wsy
  else if mv_shape == 1
    mv_wsz = 0.5*( wall.force.contact(mvWp0z, 3) - wall.force.contact(mvWp1z, 3) ) / _wAz
    mv_wsr = _mvsRadForce / _wAr
    mv_wPz = -mv_wsz
    mv_wPr = -mv_wsr
  else ; mv_shape == 2
    mv_wsr = _mvsRadForce / _wAr
    mv_wPr = -mv_wsr
  end_if
  ;
  if global.dim == 3 then  ; set mv_ws{a,r,m}
    if mv_shape == 0 then
      mv_wsa = mv_wsz
      mv_wsr = 0.5 * (mv_wsx + mv_wsy)
    else if mv_shape == 1 then
      mv_wsa = mv_wsz
      ; mv_wsr set above
    else ; mv_shape == 2
      ; mv_wsr set above
      mv_wsa = mv_wsr
    end_if
    mv_wsm = _ftOneThird * (mv_wsa + 2.0*mv_wsr)
  else ; 2D model
    mv_wsa = mv_wsy
    mv_wsr = mv_wsx
    mv_wsm = 0.5 * (mv_wsa + mv_wsr)
  end_if
  mv_wsd = mv_wsa - mv_wsr
end
;------------------------------------------------
fish define _mvsRadForce
; Return the radial force acting on the cylinder or sphere wall.
; IN: mv_shape, mvWpCyl, mvWpSph
  local FrSum = 0.0
  local Fgbl, nr
  if mv_shape == 1 then
    loop foreach cp wall.contactmap( mvWpCyl ) ; visit all active contacts of the cylinder wall
      Fgbl = vector( comp.x( contact.force.global(cp) ),   ...
                     comp.y( contact.force.global(cp) )  )
      nr = math.unit( vector( comp.x( contact.pos(cp) ),   ...
                              comp.y( contact.pos(cp) )  ) ...
                    )
      FrSum = FrSum - math.dot( Fgbl, nr )
    end_loop
  else ; mv_shape == 2
    loop foreach cp wall.contactmap( mvWpSph ) ; visit all active contacts of the sphere wall
      Fgbl = vector( comp.x( contact.force.global(cp) ),   ...
                     comp.y( contact.force.global(cp) ),   ...
                     comp.z( contact.force.global(cp) )  )
      nr = math.unit( vector( comp.x( contact.pos(cp) ),   ...
                              comp.y( contact.pos(cp) ),   ...
                              comp.z( contact.pos(cp) )  ) ...
                    )
      FrSum = FrSum - math.dot( Fgbl, nr )
    end_loop
  end_if
  _mvsRadForce = FrSum
end
;------------------------------------------------
fish define mv_wStrain
; Update the material vessel wall-based strain quantities.
; IN:  mvWp{0,1}{x,y,z}, mvWpCyl, mvWpSph
; OUT: _wd{x,y,z,r}, _wA{x,y,z,r}
;      mv_weX
;
  ; *** Update distances between opposing walls:
  if mv_shape == 0 then
    _wdx = wall.pos( mvWp1x, 1 ) - wall.pos( mvWp0x, 1 )
    _wdy = wall.pos( mvWp1y, 2 ) - wall.pos( mvWp0y, 2 )
    if global.dim == 3 then
      _wdz = wall.pos( mvWp1z, 3 ) - wall.pos( mvWp0z, 3 )
    end_if
  else if mv_shape == 1
    _wdz = wall.pos( mvWp1z, 3 ) - wall.pos( mvWp0z, 3 )
  end_if
  ; _wdr is set in _mvsUpdateRadDiam (called just before mv_wStrain)
  _mv_wAreas
  ;
  ; *** Strains:
  if mv_shape == 0 then
    mv_wex = (_wdx - _wdx0) / _wdx0
    mv_wey = (_wdy - _wdy0) / _wdy0
    if global.dim == 3 then
      mv_wez = (_wdz - _wdz0) / _wdz0
    end_if
  else if mv_shape == 1
    mv_wez = (_wdz - _wdz0) / _wdz0
    mv_wer = (_wdr - _wdr0) / _wdr0
  else ; mv_shape == 2
    mv_wer = (_wdr - _wdr0) / _wdr0
  end_if
  if global.dim == 3 then  ; set mv_we{a,r,v}
    if mv_shape == 0 then
      mv_wea = mv_wez
      mv_wer = 0.5 * (mv_wex + mv_wey)
    else if mv_shape == 1
      mv_wea = mv_wez
      ; mv_wer set above
    else ; mv_shape == 2
      ; mv_wer set above
      mv_wea = mv_wer
    end_if
    mv_wev = mv_wea + 2.0*mv_wer
  else ; 2D model
    mv_wea = mv_wey
    mv_wer = mv_wex
    mv_wev = mv_wea + mv_wer
  end_if
  mv_wed = mv_wea - mv_wer
end
;------------------------------------------------
fish define _mv_wAreas
;
; IN:  mv_wAreaMode
; OUT: _wA{x,y,z,r}
;
  if mv_shape == 0 then
    if global.dim == 3 then
      if mv_wAreaMode == 0 then
        _wAx = _wdy * _wdz
        _wAy = _wdx * _wdz
        _wAz = _wdx * _wdy
      else
        _wAx = mv_W * mv_H
        _wAy = mv_D * mv_H
        _wAz = mv_D * mv_W
      end_if
    else ; 2D model
      if mv_wAreaMode == 0 then
        _wAx = _wdy
        _wAy = _wdx
      else
        _wAx = mv_H
        _wAy = mv_W
      end_if
    end_if
  else if mv_shape == 1
    if mv_wAreaMode == 0 then
      _wAz = 0.25 * math.pi * _wdr * _wdr
      _wAr = math.pi * _wdr * _wdz
    else
      _wAz = 0.25 * math.pi * mv_W * mv_W
      _wAr = math.pi * mv_W * mv_H
    end_if
  else ; mv_shape == 2
    if mv_wAreaMode == 0 then
      _wAr = math.pi * _wdr * _wdr
    else
      _wAr = math.pi * mv_H * mv_H
    end_if
  end_if
end
;------------------------------------------------
fish define mv_wPoros
; Update the material vessel wall-based porosity.
; IN:  mvMp{1,2,3}
; OUT: mv_wn (defined above)
;
  local _sumVg = 0.0
  local _bVol
  loop foreach local bp ball.list
    if global.dim == 3 then
      _bVol = (4.0/3.0)*math.pi*ball.radius(bp)*ball.radius(bp)*ball.radius(bp)
    else ; 2D model
      _bVol = math.pi*ball.radius(bp)*ball.radius(bp)
    end_if
    _sumVg = _sumVg + _bVol
  end_loop
  loop foreach local cl clump.list
    local _cVol = clump.vol(cl)
    _sumVg = _sumVg + _cVol
  end_loop
  ;
  if _sumVg == 0.0 then
    mv_wn = 0.0
  else
    mv_wn = 1.0 - ( _sumVg / _mvVolume(false) )
  end_if
end
;************************************************
fish define mvs_on
  Array _mvsGainStored(4)
  Array _mvsGainCnt(4)
  ;
  if mvs_vLimit <= 0 then
    system.error = 'Servomechanism requires positive value for mvs_vLimit.'
  end_if
  if mvs_gainUpdateRate == 0 then ; default
    mvs_gainUpdateRate = 25
  else
    if mvs_gainUpdateRate < 1 then
      system.error = 'mvs_gainUpdateRate must be greater than or equal to one.'
    end_if
  end_if
  ;
  ; Force gain computation
  loop local i (1, 4)
    _mvsGainCnt(i) = mvs_gainUpdateRate
  end_loop
  ;
  command
    fish callback add @_mvsActive -1                  ; beginning of the step
    fish callback add @_mvsCheckMeasWallOverlap 10.11 ; just after mv_wStrain
  end_command
  if mv_shape # 0 then ; mv_shape = {1,2}
    command
      fish callback add @_mvsUpdateRadDiam 10.09  ; after EOMs, just before mv_wStrain
    end_command
  end_if
end
;------------------------------------------------
fish define mvs_off
; Turn off the servomechanism, and zero the velocities of all servo-controlled walls.
  command
    fish callback remove @_mvsActive -1
    fish callback remove @_mvsCheckMeasWallOverlap 10.11
  end_command
  if mv_shape # 0 then ; mv_shape = {1,2}
    command
      fish callback remove @_mvsUpdateRadDiam 10.09
    end_command
  end_if
  if mv_shape == 0 then
    if mvs_BCx == 1 then
      wall.vel( mvWp0x, 1 ) = 0.0
      wall.vel( mvWp1x, 1 ) = 0.0
    end_if
    if mvs_BCy == 1 then
      wall.vel( mvWp0y, 2 ) = 0.0
      wall.vel( mvWp1y, 2 ) = 0.0
    end_if
    if global.dim == 3 then
      if mvs_BCz == 1 then
        wall.vel( mvWp0z, 3 ) = 0.0
        wall.vel( mvWp1z, 3 ) = 0.0
      end_if
    end_if
  else if mv_shape == 1
    if mvs_BCz == 1 then
      wall.vel( mvWp0z, 3 ) = 0.0
      wall.vel( mvWp1z, 3 ) = 0.0
    end_if
    if mvs_BCr == 1 then
      _mvsSetRadVel( 0.0 )
    end_if
  else ; mv_shape == 2
    if mvs_BCr == 1 then
      _mvsSetRadVel( 0.0 )
    end_if
  end_if
end
;------------------------------------------------
fish define _mvsCheckMeasWallOverlap
; IN: _wd{x,y,z,r}, _mvMp{Ax,Rad}Len
;
  local _wdHt
  if global.dim == 3 then
    if mv_shape == 2 then
      _wdHt = _wdr
    else ; mv_shape = {0,1}
      _wdHt = _wdz
    end_if
  else ; 2D model
    _wdHt = _wdy
  end_if
  if _wdHt <= _mvMpAxLen then
    system.error = 'Material-vessel axial (upper/lower) walls overlap the measurement regions, decrease mv_inset{L,D}Fac.'
  end_if
  ;
  local overlapSides = false
  if mv_shape == 0 then
    if _wdx <= _mvMpRadLenX then
      overlapSides = true
    end_if
    if global.dim == 3 then
      if _wdy <= _mvMpRadLenY then
        overlapSides = true
      end_if
    end_if
  else ; mv_shape == {1,2}
    if _wdr <= _mvMpRadLenX then
      overlapSides = true
    end_if
  end_if
  ;
  if overlapSides then
    system.error = 'Material-vessel side walls overlap the measurement regions, decrease mv_inset{L,D}Fac.'
  end_if
end
;------------------------------------------------
fish define mvs_setBCs
; Set the velocity conditions, pressure conditions are enforced by _mvsActive.
  if mv_shape == 0 then
    if mvs_BCx == 0 then
      wall.vel( mvWp0x, 1 ) = -mvs_BCxVal
      wall.vel( mvWp1x, 1 ) =  mvs_BCxVal
    else
      if mvs_BCxVal <= 0.0 then
        system.error = 'mvs_setBCs: Pressure (mvs_BCxVal) must be non-zero and positive.'
      end_if
    end_if
    if mvs_BCy == 0 then
      wall.vel( mvWp0y, 2 ) = -mvs_BCyVal
      wall.vel( mvWp1y, 2 ) =  mvs_BCyVal
    else
      if mvs_BCyVal <= 0.0 then
        system.error = 'mvs_setBCs: Pressure (mvs_BCyVal) must be non-zero and positive.'
      end_if
    end_if
    if global.dim == 3 then
      if mvs_BCz == 0 then
        wall.vel( mvWp0z, 3 ) = -mvs_BCzVal
        wall.vel( mvWp1z, 3 ) =  mvs_BCzVal
      else
        if mvs_BCzVal <= 0.0 then
          system.error = 'mvs_setBCs: Pressure (mvs_BCzVal) must be non-zero and positive.'
        end_if
      end_if
    end_if
  else if mv_shape == 1
    if mvs_BCz == 0 then
      wall.vel( mvWp0z, 3 ) = -mvs_BCzVal
      wall.vel( mvWp1z, 3 ) =  mvs_BCzVal
    else
      if mvs_BCzVal <= 0.0 then
        system.error = 'mvs_setBCs: Pressure (mvs_BCzVal) must be non-zero and positive.'
      end_if
    end_if
    if mvs_BCr == 0 then
      _mvsSetRadVel( mvs_BCrVal )
    else
      if mvs_BCrVal <= 0.0 then
        system.error = 'mvs_setBCs: Pressure (mvs_BCrVal) must be non-zero and positive.'
      end_if
    end_if
  else ; mv_shape == 2
    if mvs_BCr == 0 then
      _mvsSetRadVel( mvs_BCrVal )
    else
      if mvs_BCrVal <= 0.0 then
        system.error = 'mvs_setBCs: Pressure (mvs_BCrVal) must be non-zero and positive.'
      end_if
    end_if
  end_if
  ;
  _mvsEnforceVlimit
end
;------------------------------------------------
fish define mvs_applyConfinement( Pc, eqPTol, ARatLimit, stepLimit )
; Attempt to confine the specimen by activating the servo control in all direcs.
; Confinement applicaton is successful if both mvs_eqP and ft_eq indicate that static equilibrium
; has been obtained. If confinement application is unsuccessful, then throw an error.
;
; PARAMS:
;   Pc        : confining pressure, applied equally in all direcs.
;   eqPTol    : equil-pressure tolerance
;   ARatLimit : equil-ratio limit
;   stepLimit : step limit
;
  local myStr = '** mvs_applyConfinement (entering with parameters:'
  myStr = myStr + ' Pc: '+string(Pc)+','
  myStr = myStr + ' eqPTol: '+string(eqPTol)+','
  myStr = myStr + ' ARatLimit: '+string(ARatLimit)+','
  myStr = myStr + ' stepLimit: '+string(stepLimit)+')'
  io.out( myStr )

  if mv_shape == 0 then
    mvs_BCx = 1
    mvs_BCxVal = Pc
    mvs_BCy = 1
    mvs_BCyVal = Pc
    if global.dim == 3 then
      mvs_BCz = 1
      mvs_BCzVal = Pc
    end_if
  else if mv_shape == 1
    mvs_BCz = 1
    mvs_BCzVal = Pc
    mvs_BCr = 1
    mvs_BCrVal = Pc
  else ; mv_shape == 2
    mvs_BCr = 1
    mvs_BCrVal = Pc
  end_if
  mvs_setBCs

  local retCode
  retCode = mvs_eqP( eqPTol, stepLimit )
  if retCode # 0 then
    system.error = 'Confinement application failed: did not reach equil-pressure tolerance.'
  end_if

  retCode = ft_eq( ARatLimit, stepLimit )
  if retCode # 0 then
    system.error = 'Confinement application failed: did not reach equilibrium-ratio limit.'
  end_if
  io.out('** mvs_applyConfinement, Confinement application successful (exiting).')
end
;------------------------------------------------
fish define mvs_eqP( eqPTol, stepLimit )
; Cycle the model until either the pressures of all servo-controlled walls are within
; the equilibrium-pressure tolerance of the target values or the step limit is reached.
; PARAMS:
;   eqPTol    : equilibrium-pressure tolerance
;   stepLimit : step limit (for {model solve cycles} command)
; Returns:
;   0 : equilibrium-pressure tolerance met
;   1 : step limit reached before equilibrium-pressure tolerance met
;
  local myStr = '** mvs_eqP (entering with parameters:'
  myStr = myStr + ' eqPTol: '+string(eqPTol)+','
  myStr = myStr + ' stepLimit: '+string(stepLimit)+')'
  io.out( myStr )
  ;
  _eqPTol = eqPTol ; function _eqPMet cannot have parameters, so must use this global
  command
    model cycle 1
  end_command
  command
    model solve fish-halt @_eqPMet cycles [stepLimit]
  end_command
  local returnCode = 0
  if _eqPMet # 0 then
    returnCode = 0
  else
    returnCode = 1
  end_if
  ;
  myStr = '** mvs_eqP (exiting with condition: '
  if returnCode == 0 then
    myStr = myStr + 'eqPTol met)'
  else
    myStr = myStr + 'stepLimit reached, but eqPTol not met)'
  end_if
  io.out( myStr )
  if mv_shape == 0 then
    if mvs_BCx == 1 then
      io.out('     [_eqPxeps: '+string(_eqPxeps)+']')
    end_if
    if mvs_BCy == 1 then
      io.out('     [_eqPyeps: '+string(_eqPyeps)+']')
    end_if
    if global.dim == 3 then
      if mvs_BCz == 1 then
        io.out('     [_eqPzeps: '+string(_eqPzeps)+']')
      end_if
    end_if
  else if mv_shape == 1
    if mvs_BCz == 1 then
      io.out('     [_eqPzeps: '+string(_eqPzeps)+']')
    end_if
    if mvs_BCr == 1 then
      io.out('     [_eqPreps: '+string(_eqPreps)+']')
    end_if
  else ; mv_shape == 2
    if mvs_BCr == 1 then
      io.out('     [_eqPreps: '+string(_eqPreps)+']')
    end_if
  end_if
  ;
  mvs_eqP = returnCode
end
;------------------------------------------------
fish define _eqPMet  ;{o: _eqP{x,y,z,r}eps; i: _eqPTol}
;
  local AllMet = 1
  if mv_shape == 0 then
    if mvs_BCx == 1 then
      if mvs_BCxVal > 0.0 then
        _eqPxeps = math.abs(mv_wPx - mvs_BCxVal) / mvs_BCxVal
      else
        _eqPxeps = 0.0
      end_if
      if _eqPxeps > _eqPTol then
        AllMet = 0
      end_if
    end_if
    if mvs_BCy == 1 then
      if mvs_BCyVal > 0.0 then
        _eqPyeps = math.abs(mv_wPy - mvs_BCyVal) / mvs_BCyVal
      else
        _eqPyeps = 0.0
      end_if
      if _eqPyeps > _eqPTol then
        AllMet = 0
      end_if
    end_if
    if global.dim == 3 then
      if mvs_BCz == 1 then
        if mvs_BCzVal > 0.0 then
          _eqPzeps = math.abs(mv_wPz - mvs_BCzVal) / mvs_BCzVal
        else
          _eqPzeps = 0.0
        end_if
        if _eqPzeps > _eqPTol then
          AllMet = 0
        end_if
      end_if
    end_if
  else if mv_shape == 1
    if mvs_BCz == 1 then
      if mvs_BCzVal > 0.0 then
        _eqPzeps = math.abs(mv_wPz - mvs_BCzVal) / mvs_BCzVal
      else
        _eqPzeps = 0.0
      end_if
      if _eqPzeps > _eqPTol then
        AllMet = 0
      end_if
    end_if
    if mvs_BCr == 1 then
      if mvs_BCrVal > 0.0 then
        _eqPreps = math.abs(mv_wPr - mvs_BCrVal) / mvs_BCrVal
      else
        _eqPreps = 0.0
      end_if
      if _eqPreps > _eqPTol then
        AllMet = 0
      end_if
    end_if
  else ; mv_shape == 2
    if mvs_BCr == 1 then
      if mvs_BCrVal > 0.0 then
        _eqPreps = math.abs(mv_wPr - mvs_BCrVal) / mvs_BCrVal
      else
        _eqPreps = 0.0
      end_if
      if _eqPreps > _eqPTol then
        AllMet = 0
      end_if
    end_if
  end_if
  _eqPMet = AllMet
end
;------------------------------------------------
fish define _mvsEnforceVlimit
  if mv_shape == 0 then
    if math.abs( wall.vel(mvWp0x,1) ) > mvs_vLimit then
      wall.vel(mvWp0x,1) = mvs_vLimit * ( wall.vel(mvWp0x,1) / math.abs(wall.vel(mvWp0x,1)) ...
                                        )
    end_if
    if math.abs( wall.vel(mvWp1x,1) ) > mvs_vLimit then
      wall.vel(mvWp1x,1) = mvs_vLimit * ( wall.vel(mvWp1x,1) / math.abs(wall.vel(mvWp1x,1)) ...
                                        )
    end_if
    ;
    if math.abs( wall.vel(mvWp0y,2) ) > mvs_vLimit then
      wall.vel(mvWp0y,2) = mvs_vLimit * ( wall.vel(mvWp0y,2) / math.abs(wall.vel(mvWp0y,2)) ...
                                        )
    end_if
    if math.abs( wall.vel(mvWp1y,2) ) > mvs_vLimit then
      wall.vel(mvWp1y,2) = mvs_vLimit * ( wall.vel(mvWp1y,2) / math.abs(wall.vel(mvWp1y,2)) ...
                                        )
    end_if
    ;
    if global.dim == 3 then
      if math.abs( wall.vel(mvWp0z,3) ) > mvs_vLimit then
        wall.vel(mvWp0z,3) = mvs_vLimit * ( wall.vel(mvWp0z,3) / math.abs(wall.vel(mvWp0z,3)) ...
                                          )
      end_if
      if math.abs( wall.vel(mvWp1z,3) ) > mvs_vLimit then
        wall.vel(mvWp1z,3) = mvs_vLimit * ( wall.vel(mvWp1z,3) / math.abs(wall.vel(mvWp1z,3)) ...
                                          )
      end_if
    end_if
  else if mv_shape == 1
    if math.abs( wall.vel(mvWp0z,3) ) > mvs_vLimit then
      wall.vel(mvWp0z,3) = mvs_vLimit * ( wall.vel(mvWp0z,3) / math.abs(wall.vel(mvWp0z,3)) ...
                                        )
    end_if
    if math.abs( wall.vel(mvWp1z,3) ) > mvs_vLimit then
      wall.vel(mvWp1z,3) = mvs_vLimit * ( wall.vel(mvWp1z,3) / math.abs(wall.vel(mvWp1z,3)) ...
                                        )
    end_if
    ;
    local rVel
    if math.abs( _mvsRadVel ) > mvs_vLimit then
      rVel = mvs_vLimit * ( _mvsRadVel / math.abs(_mvsRadVel) ...
                          )
      _mvsSetRadVel( rVel )
    end_if
  else ; mv_shape == 2
    if math.abs( _mvsRadVel ) > mvs_vLimit then
      rVel = mvs_vLimit * ( _mvsRadVel / math.abs(_mvsRadVel) ...
                          )
      _mvsSetRadVel( rVel )
    end_if
  end_if
 end
;------------------------------------------------
 fish define _mvsSetRadVel( rVel )
; Set the radial velocity of all cylinder- or sphere-wall vertices to rVel.
; IN: mv_shape, mvWpCyl, mvWpSph
; PARAM:
;   rVel : radial velocity
  _mvsRadVel = rVel
  local nr
  if mv_shape == 1 then
    loop foreach vp wall.vertexlist( mvWpCyl )
      nr = math.unit( vector( comp.x( wall.vertex.pos(vp) ),   ...
                              comp.y( wall.vertex.pos(vp) )  ) ...
                    )
      wall.vertex.vel(vp) = rVel * nr
    end_loop
  else ; mv_shape == 2
    loop foreach vp wall.vertexlist( mvWpSph )
      nr = math.unit( vector( comp.x( wall.vertex.pos(vp) ),   ...
                              comp.y( wall.vertex.pos(vp) ),   ...
                              comp.z( wall.vertex.pos(vp) )  ) ...
                    )
      wall.vertex.vel(vp) = rVel * nr
    end_loop
  end_if
 end
;------------------------------------------------
fish define _mvsUpdateRadDiam
; Update diameter of the cylinder- or sphere-wall (stored as _wdr).
;
  _wdr = _wdr + 2.0 * _mvsRadVel * mech.timestep
end
;------------------------------------------------
fish define _mvsActive
; Control velocities of wall pairs with pressure BCs.
;
  local wGain, wVel
  if mv_shape == 0 then
    if mvs_BCx == 1 then
      wGain = _mvsGain(1)
      if wGain == -1.0 then
        wVel = -mvs_vLimit  ; closing at velocity limit
      else
        wVel = wGain * ( mv_wPx - mvs_BCxVal )
      end_if
      wall.vel( mvWp0x, 1 ) = -wVel
      wall.vel( mvWp1x, 1 ) =  wVel
    end_if
    if mvs_BCy == 1 then
      wGain = _mvsGain(2)
      if wGain == -1.0 then
        wVel = -mvs_vLimit  ; closing at velocity limit
      else
        wVel = wGain * ( mv_wPy - mvs_BCyVal )
      end_if
      wall.vel( mvWp0y, 2 ) = -wVel
      wall.vel( mvWp1y, 2 ) =  wVel
    end_if
    if global.dim == 3 then
      if mvs_BCz == 1 then
        wGain = _mvsGain(3)
        if wGain == -1.0 then
          wVel = -mvs_vLimit  ; closing at velocity limit
        else
          wVel = wGain * ( mv_wPz - mvs_BCzVal )
        end_if
        wall.vel( mvWp0z, 3 ) = -wVel
        wall.vel( mvWp1z, 3 ) =  wVel
      end_if
    end_if
  else if mv_shape == 1
    if mvs_BCz == 1 then
      wGain = _mvsGain(3)
      if wGain == -1.0 then
        wVel = -mvs_vLimit  ; closing at velocity limit
      else
        wVel = wGain * ( mv_wPz - mvs_BCzVal )
      end_if
      wall.vel( mvWp0z, 3 ) = -wVel
      wall.vel( mvWp1z, 3 ) =  wVel
    end_if
    if mvs_BCr == 1 then
      wGain = _mvsGain(4)
      if wGain == -1.0 then
        wVel = -mvs_vLimit  ; closing at velocity limit
      else
        wVel = wGain * ( mv_wPr - mvs_BCrVal )
      end_if
      _mvsSetRadVel( wVel )
    end_if
  else ; mv_shape == 2
    if mvs_BCr == 1 then
      wGain = _mvsGain(4)
      if wGain == -1.0 then
        wVel = -mvs_vLimit  ; closing at velocity limit
      else
        wVel = wGain * ( mv_wPr - mvs_BCrVal )
      end_if
      _mvsSetRadVel( wVel )
    end_if
  end_if
  _mvsEnforceVlimit
end
;------------------------------------------------
fish define _mvsGain( dir )
; Return the gain for the wall-pair, or cylinder/sphere-wall in direction [dir].
; If gain cannot be determined (KnSum = 0), then return -1.0.
; PARAM:
;   dir : {1,2,3,4} = {'x','y','z','r'} [int]
;
; IN: mvs_gainUpdateRate, _mvsGainStored(4), _mvsGainCnt(4)
;
  _mvsGainCnt(dir) = _mvsGainCnt(dir) + 1
  if _mvsGainCnt(dir) >= mvs_gainUpdateRate then
    _mvsGainStored(dir) = _mvsGainCompute(dir)
    _mvsGainCnt(dir) = 0
  end_if
  _mvsGain = _mvsGainStored(dir)
end
;------------------------------------------------
fish define _mvsGainCompute( dir )
; PARAM:
;   dir : {1,2,3,4} = {'x','y','z','r'} [int]
;
  local Area, wp0, wp1
  case_of dir
      system.error = 'dir is not {1,2,3,4}.'
    case 1 ;'x'
      Area = 2.0 * _wAx  ; total platen area perpendicular to x-direc.
      wp0 = mvWp0x
      wp1 = mvWp1x
    case 2 ;'y'
      Area = 2.0 * _wAy  ; total platen area perpendicular to y-direc.
      wp0 = mvWp0y
      wp1 = mvWp1y
    case 3 ;'z'
      Area = 2.0 * _wAz  ; total platen area perpendicular to z-direc.
      wp0 = mvWp0z
      wp1 = mvWp1z
    case 4 ;'r'
      Area = _wAr ; lateral surface area
      if mv_shape == 1 then
        wp0 = mvWpCyl
      else ; mv_shape == 2
        wp0 = mvWpSph
      end_if
  end_case
  local cp, Alpha = 0.5, KnSum = 0.0
  loop foreach cp wall.contactmap( wp0 )
    KnSum = KnSum + contact.prop( cp, 'kn' )
  end_loop
  if mv_shape == 0 then
    loop foreach cp wall.contactmap( wp1 )
      KnSum = KnSum + contact.prop( cp, 'kn' )
    end_loop
  end_if
  if KnSum > 0.0 then
    _mvsGainCompute = (Alpha * Area) / (KnSum * mech.timestep)
  else
    _mvsGainCompute = -1.0
  end_if
end
;************************************************
; Support for microstructural plots, public functions: msX
;   msOn, msOff, msUpdateRate, msForceUpdate, msBoxDefine
;   GEOMETRY SET ITEMS:
;     _msPoly3, _msPoly4, _msLineA, _msLineB, _msArc, _msDisk, _msSkirt,
;     _msCylinder, _msSphere, _msLineThick2D, _msCircle2D
;   SUPPORT FUNCTIONS:
;      _msGrainPiecePt, _msLocalS
;
; Each microstructural plot is called a plot set, in which the plot information is stored as a
; geometry set, and displayed by the geometry plot item by specifying: {ColorBy: Set}, and
; {Sets: <geometry set name>}. The plot sets are regenerated at a specified rate (msUpdateRate)
; during cycling, and the regeneration can be forced to occur via @msForceUpdate.
; An axis-aligned microstructural box (defined by @msBoxDefine) is associated with the plot sets.
; The box is displayed by the geometry plot item by specifying: {ColorBy: Set}, and
; {Sets: msBox}. The grains with centers inside the box can be displayed with either: (a) the ball
; and clump plot items by specifying: {Color By: Text Val: msBoxIN}, or (b) the "grain" and
; "faced grain" plot sets. The contact-based plot sets display only the entities joining the
; grains in the box. The faced grain plot set displays only the faces joining grains with centers
; inside the box. The following plot sets are available (each has inputs to control sizing):
;   Grain-based:
;     _msGN_Make  (grains)
;     _msFG_Make  (faced grains), msFG_Track
;   Contact-based:
;     _msCB_Make  (contact bonds)
;     _msPBi_Make (parallel bonds as interfaces)
;     _msPBc_Make (parallel bonds as cement)
;     _msSBi_Make (soft bonds as interfaces)
;     _msFJi_Make (flat-joint interfaces)
;   Cracks:
;     _msCK_Make  (gap-based cracks)
;************************************************
fish define msOn
  if _msOn then
    exit
  end_if
  ;
  if msUpdateRate == 0 then ; default
    msUpdateRate = 500
  else
    if msUpdateRate < 1 then
      system.error = 'msUpdateRate must be greater than or equal to one.'
    end_if
  end_if
  ;
  if _msBoxDefined = false then ; default, infinite-size box
    if global.dim == 3 then
      msBoxDefine( vector(0.0, 0.0, 0.0), vector(1e20, 1e20, 1e20) )
    else ; 2D model
      msBoxDefine( vector(0.0, 0.0)     , vector(1e20, 1e20)       )
    end_if
  end_if
  ;
  command
    fish callback add @_msUpdate 10.10 ; after EOMs
  end_command
  ;
  _msOn = true
  msForceUpdate
end
;------------------------------------------------
fish define msOff
  if _msOn == false then
    exit
  end_if
  ;
  command
    fish callback remove @_msUpdate 10.10
  end_command
  _msOn = false
end
;------------------------------------------------
fish define msForceUpdate
  if _msOn then
    _msUpdateCnt = msUpdateRate ; force the update on next line
    _msUpdate
  end_if
end
;------------------------------------------------
fish define msBoxDefine( ctr, dims )
; Define the location and dimensions of the axis-aligned microstructural box, and update
; the associated geometry set.
;
; OUTPUT: msBoxCenter - box center (vector)
;         msBoxDims   - box lengths in x, y and z directions (vector)
;
  msBoxCenter = ctr
  msBoxDims = dims
  _msBoxGeomSetUpdate
  _msBoxDefined = true
end
;------------------------------------------------
fish define _msUpdate
  _msUpdateCnt = _msUpdateCnt + 1
  if _msUpdateCnt >= msUpdateRate then
    _msClear
    _msBoxMarkGrains
    ;
    _msGN_Make
    _msFG_Make
    _msCB_Make
    _msPBi_Make
    _msPBc_Make
    _msSBi_Make
    _msFJi_Make
    _msCK_Make
    ;
    _msUpdateCnt = 0
  end_if
end
;------------------------------------------------
fish define _msClear
  if _msCleared then
    geom.set.delete( geom.set.find( 'grains' ) )
    geom.set.delete( geom.set.find( 'faced grains' ) )
    geom.set.delete( geom.set.find( 'contact bonds' ) )
    geom.set.delete( geom.set.find( 'pbond interfaces' ) )
    geom.set.delete( geom.set.find( 'pbond cement' ) )
    geom.set.delete( geom.set.find( 'sbond interfaces' ) )
    geom.set.delete( geom.set.find( 'FJ interfaces' ) )
    geom.set.delete( geom.set.find( 'cracks' ) )
  end_if
  local gs = geom.set.create( 'grains' )
        gs = geom.set.create( 'faced grains' )
        gs = geom.set.create( 'contact bonds' )
        gs = geom.set.create( 'pbond interfaces' )
        gs = geom.set.create( 'pbond cement' )
        gs = geom.set.create( 'sbond interfaces' )
        gs = geom.set.create( 'FJ interfaces' )
        gs = geom.set.create( 'cracks' )
  _msCleared = true
end
;------------------------------------------------
fish define _msBoxGeomSetUpdate
; Update the geometry set of the microstructural box.
;
; INPUT:  msBoxCenter, msBoxDims (see msBoxSet)
; EFFECT: geometry set 'msBox' updated
;
;   8*---^-----*7
;  4/    | y 3/|
;  *---------* *6 --->x
;  |         |/
;  *---------*
;  1         2
;
  if _msBoxGeomSetUpdated then
    geom.set.delete( geom.set.find( 'msBox' ) )
  end_if
  local gs = geom.set.create( 'msBox' )
  _msBoxGeomSetUpdated = true
  ;
  local P1, P2, P3, P4
  if global.dim == 3 then
    P1 = vector( comp.x(msBoxCenter) - 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) - 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) + 0.5 * comp.z(msBoxDims) )
    P2 = vector( comp.x(msBoxCenter) + 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) - 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) + 0.5 * comp.z(msBoxDims) )
    P3 = vector( comp.x(msBoxCenter) + 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) + 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) + 0.5 * comp.z(msBoxDims) )
    P4 = vector( comp.x(msBoxCenter) - 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) + 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) + 0.5 * comp.z(msBoxDims) )
    P5 = vector( comp.x(msBoxCenter) - 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) - 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) - 0.5 * comp.z(msBoxDims) )
    P6 = vector( comp.x(msBoxCenter) + 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) - 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) - 0.5 * comp.z(msBoxDims) )
    P7 = vector( comp.x(msBoxCenter) + 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) + 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) - 0.5 * comp.z(msBoxDims) )
    P8 = vector( comp.x(msBoxCenter) - 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) + 0.5 * comp.y(msBoxDims), ...
                 comp.z(msBoxCenter) - 0.5 * comp.z(msBoxDims) )
    _msPoly4( gs, '', P1, P2, P3, P4 )
    _msPoly4( gs, '', P2, P6, P7, P3 )
    _msPoly4( gs, '', P6, P5, P8, P7 )
    _msPoly4( gs, '', P5, P1, P4, P8 )
    _msPoly4( gs, '', P4, P3, P7, P8 )
    _msPoly4( gs, '', P1, P5, P6, P2 )
  else ; 2D model
    P1 = vector( comp.x(msBoxCenter) - 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) - 0.5 * comp.y(msBoxDims) )
    P2 = vector( comp.x(msBoxCenter) + 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) - 0.5 * comp.y(msBoxDims) )
    P3 = vector( comp.x(msBoxCenter) + 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) + 0.5 * comp.y(msBoxDims) )
    P4 = vector( comp.x(msBoxCenter) - 0.5 * comp.x(msBoxDims), ...
                 comp.y(msBoxCenter) + 0.5 * comp.y(msBoxDims) )
    _msPoly4( gs, '', P1, P2, P3, P4 )
  end_if
end
;------------------------------------------------
fish define _msBoxMarkGrains
; Mark the grains with centers inside the microstructural box.
;
; INPUT:  msBoxCenter, msBoxDims (see msBoxSet)
; EFFECT: 'msBox' property of all grains is set to either 'msBoxIN' or 'msBoxOUT'.
;
  local xlo = comp.x(msBoxCenter) - comp.x(0.5*msBoxDims)
  local xhi = comp.x(msBoxCenter) + comp.x(0.5*msBoxDims)
  local ylo = comp.y(msBoxCenter) - comp.y(0.5*msBoxDims)
  local yhi = comp.y(msBoxCenter) + comp.y(0.5*msBoxDims)
  if global.dim == 3 then
    local zlo = comp.z(msBoxCenter) - comp.z(0.5*msBoxDims)
    local zhi = comp.z(msBoxCenter) + comp.z(0.5*msBoxDims)
  end_if
  ;
  loop foreach local bp ball.list
    ball.prop( bp, 'msBox' ) = 'msBoxOUT'
    if global.dim == 3 then
      if   (comp.x(ball.pos(bp)) >= xlo) & (comp.x(ball.pos(bp)) <= xhi) ...
         & (comp.y(ball.pos(bp)) >= ylo) & (comp.y(ball.pos(bp)) <= yhi) ...
         & (comp.z(ball.pos(bp)) >= zlo) & (comp.z(ball.pos(bp)) <= zhi) then
        ball.prop( bp, 'msBox' ) = 'msBoxIN'
      end_if
    else ; 2D model
      if   (comp.x(ball.pos(bp)) >= xlo) & (comp.x(ball.pos(bp)) <= xhi) ...
         & (comp.y(ball.pos(bp)) >= ylo) & (comp.y(ball.pos(bp)) <= yhi) then
        ball.prop( bp, 'msBox' ) = 'msBoxIN'
      end_if
    end_if
  end_loop
  ;
  loop foreach local cl clump.list
    clump.prop( cl, 'msBox' ) = 'msBoxOUT'
    if global.dim == 3 then
      if   (comp.x(clump.pos(cl)) >= xlo) & (comp.x(clump.pos(cl)) <= xhi) ...
         & (comp.y(clump.pos(cl)) >= ylo) & (comp.y(clump.pos(cl)) <= yhi) ...
         & (comp.z(clump.pos(cl)) >= zlo) & (comp.z(clump.pos(cl)) <= zhi) then
        clump.prop( cl, 'msBox' ) = 'msBoxIN'
      end_if
    else ; 2D model
      if   (comp.x(clump.pos(cl)) >= xlo) & (comp.x(clump.pos(cl)) <= xhi) ...
         & (comp.y(clump.pos(cl)) >= ylo) & (comp.y(clump.pos(cl)) <= yhi) then
        clump.prop( cl, 'msBox' ) = 'msBoxIN'
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msGN_Make
; The grain plot set displays each grain as a sphere --- only ball-shaped grains are displayed,
; clump-shaped grains are not supported. The sphere is centered at the ball location, and has
; radius equal to the scale factor {msGN_sfacRad} times the ball radius. For the 2D model, the
; grains are displayed as circles.
;
; INPUT: msGN_sfacRad - scale factor applied to sphere radius (in range (0.0, 1.0])
;
  if msGN_sfacRad == 0 then ;default
    msGN_sfacRad = 1.0
  else
    if (msGN_sfacRad <= 0.0) | (msGN_sfacRad > 1.0) then
      system.error = '_msGN_Make: msGN_sfacRad must be in range (0.0, 1.0].'
    end_if
  end_if
 ;
  local gs = geom.set.find('grains')
  loop foreach bp ball.list
    if ball.prop( bp, 'msBox' ) == 'msBoxIN' then
      if global.dim == 3 then
        _msSphere( gs, '', ...
                   ball.pos(bp), msGN_sfacRad * ball.radius(bp) )
      else ; 2D model
        _msCircle2D( gs, '', ...
                     ball.pos(bp), msGN_sfacRad * ball.radius(bp) )
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msFG_Make
; The faced grain plot set displays each grain as a faced grain --- only ball-shaped grains are
; displayed, clump-shaped grains are not supported. The faced grains at the boundary of the
; periodic space are not displayed properly. The faced grains are created when the flat-
; joint model is installed at the ball-ball contacts of a packed ball assembly such that each
; face remains rigidly connected to its corresponding grain during subsequent motion. The faced
; grain is drawn as a spherical core with a skirted face at the associated notional surface of
; each flat-jointed contact.
;
; The core and skirted faces of each grain can be displayed by the geometry plot item by
; specifying {ColorBy: Group} and {Sets: faced grains}, with {Colors:} used to turn each
; entity on/off and specify its color. For the 2D model, two geometry plot items should be
; used. The first geometry plot item turns on the entities 'core' and 'grain in skirt', with
; {Edges: Off}, {Polys: checked} and {Polys: Wireframe: unchecked}. The second geometry plot
; item turns on the entity 'skirted face', with {Edges: On} and {Polys: unchecked}.
;
; The visualization scheme for each entity is as follows.
;   (a) Core (group 'core').
;       The core is drawn as a sphere with radius equal to the minimum of all facet radial
;       distances. For the 2D model, the core is drawn as a circle.
;   (b) Skirted Face (group 'skirted face', also 'grain in skirt' for the 2D model).
;       The skirted face is drawn as a disk (line for the 2D model) surrounded by a skirt
;       that extends toward the core center until it intersects the core surface.
;
; INPUT: msFG_TrackOn (see msFG_Track)
;        msFG_seedID  - id number of ball to use as the seed grain. If value is zero, then
;                       grains in the microstructural box are drawn.
;        msFG_seedNum - number of grains connected directly to the seed grain. Each of these
;                       grains will be drawn as a faced grain.
;
  if msFG_TrackOn == false then
    exit
  end_if
  if msFG_seedID # 0 then
    if (msFG_seedID <= 0) then
      system.error = '_msFG_Make: msFG_seedID must be positive.'
    end_if
    if msFG_seedNum == 0 then ; default
      msFG_seedNum = 1
    end_if
  end_if
  ;
  local gs = geom.set.find('faced grains')
  local bp
  if msFG_seedID == 0 then
    loop foreach bp ball.list
      if ball.prop( bp, 'msBox' ) == 'msBoxIN' then
        _msFGdrawFacedGrain( gs, bp )
      end_if
    end_loop
  else ; msFG_seedID > 0
    bp = ball.find(msFG_seedID)
    _msFGdrawFacedGrain( gs, bp )
    local numFG = 1
    loop foreach local cp ball.contactmap.all(bp)
      if contact.model(cp) == 'flatjoint' then
        if numFG < msFG_seedNum then
          local bp_other
          if contact.end1(cp) == bp then
            bp_other = contact.end2(cp)
          else
            bp_other = contact.end1(cp)
          end_if
          _msFGdrawFacedGrain( gs, bp_other )
          numFG = numFG + 1
        end_if
      end_if
    end_loop
  end_if
end
;------------------------------------------------
fish define _msFGdrawFacedGrain( gs, bp )
  local radCore = _msFGcoreRad(bp)
  _msFGdrawCore(         gs, bp, radCore )
  _msFGdrawSkirtedFaces( gs, bp, radCore )
end
;------------------------------------------------
fish define msFG_Track
; Establish and begin tracking the faced-grain microstructure, which can be visualized by the
; faced grain plot set (_msFG_Make). The faced-grain microstructure is established by defining
; the topology and geometry of all FJ faces. Each face remains rigidly connected to a piece of
; its corresponding grain during subsequent motion. Faced-grain information consists of the
; radial distance of each face from the piece center, and the orientation of each face on the
; grain. The faced-grain information does not change, and is used to draw the faced grains
; during subsequent motion by tracking the grain orientations. The faced-grain information is
; stored in the following extra variables of each flat-jointed contact (with 1 and 2 denoting
; the local piece number):
;   {rf, nf} (3D model)
;   {rf, af} (2D model)
;     rf{1,2} : radial distance of face from piece center [FLT]
;     nf{1,2} : initial unit normal of face, outwardly directed from piece [VEC3]
;     af{1,2} : initial angle of face unit normal measured ccw wrt +x-axis [FLT, radians,
;                 in [0, 2*pi]]
; OUTPUT: msFG_TrackOn      - microstructural tracking flag
;         msFG_cex{1,2,3,4} - slots of contact extra field
;                               {rf1, rf2, nf1, nf2} (3D only)
;                               {rf1, rf2, af1, af2} (2D only)
; I/O:    ft_cexNum         - number of extra slots associated with contacts
; EFFECT: orientation tracking is turned on,
;         rotation attribute of all balls is set to zero (PFC2D only),
;         extra fields are created & filled for all flat-jointed contacts
;
  msFG_TrackOn = true
  ;
  ft_cexNum = int( ft_cexNum )
  msFG_cex1 = ft_cexNum + 1
  msFG_cex2 = ft_cexNum + 2
  msFG_cex3 = ft_cexNum + 3
  msFG_cex4 = ft_cexNum + 4
  ft_cexNum = msFG_cex4
  ;
  command
    model orientation-tracking on
  end_command
  ;
  if global.dim == 2 then
    loop foreach local bp ball.list
      ft_bRotationSet(bp, 0.0)
    end_loop
  end_if
  ;
  loop foreach local cp contact.list.all
    if contact.model(cp) == 'flatjoint' then
      if type.pointer.id(cp) == contact.typeid('ball-ball') then
        local nf, rf, af
        nf = contact.pos(cp) - ball.pos( contact.end1(cp) )
        rf = math.mag( nf ) - (0.5 * contact.prop( cp, 'fj_gap0' ))
        contact.extra(cp, msFG_cex1) = rf
        if global.dim == 3 then
          nf = math.unit( nf )
          contact.extra(cp, msFG_cex3) = nf
        else ; 2D model
          af = _ftAng2D( nf )
          contact.extra(cp, msFG_cex3) = af
        end_if
        ;
        nf = contact.pos(cp) - ball.pos( contact.end2(cp) )
        rf = math.mag( nf ) - (0.5 * contact.prop( cp, 'fj_gap0' ))
        contact.extra(cp, msFG_cex2) = rf
        if global.dim == 3 then
          nf = math.unit( nf )
          contact.extra(cp, msFG_cex4) = nf
        else ; 2D model
          af = _ftAng2D( nf )
          contact.extra(cp, msFG_cex4) = af
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msFGcoreRad( bp )
; Return core radius of [bp].  If no facets, it is the ball radius;
; otherwise, it is the minimum of all facet radial distances.
  local rfMin = ball.radius(bp)
  local rf
  loop foreach local cp ball.contactmap.all(bp)
    if contact.model(cp) == 'flatjoint' then
      if type.pointer.id(cp) == contact.typeid('ball-ball') then
        if contact.end1(cp) == bp then
          rf = contact.extra(cp, msFG_cex1)
        else
          rf = contact.extra(cp, msFG_cex2)
        end_if
        rfMin = math.min( rf, rfMin )
      end_if
    end_if
  end_loop
  _msFGcoreRad = rfMin
end
;------------------------------------------------
fish define _msFGdrawCore( gs, bp, radCore )
  if global.dim == 3 then
    _msSphere(   gs, 'core', ...
                     ball.pos(bp), radCore )
  else ; 2D model
    _msCircle2D( gs, 'core', ...
                     ball.pos(bp), radCore )
  end_if
end
;------------------------------------------------
fish define _msFGdrawSkirtedFaces( gs, bp, radCore )
; Draw the skirted faces of the ball, by visiting all flat-jointed contacts around the ball.
;
  if global.dim == 3 then
    _msFGdrawSkirtedFaces3D( gs, bp, radCore )
  else ; 2D model
    _msFGdrawSkirtedFaces2D( gs, bp, radCore )
  end_if
end
;------------------------------------------------
fish define _msFGdrawSkirtedFaces2D( gs, bp, radCore )
  local rf
  local af
  loop foreach local cp ball.contactmap.all(bp)
    if contact.model(cp) == 'flatjoint' then
      if type.pointer.id(cp) == contact.typeid('ball-ball') then
        local bp_other
        if contact.end1(cp) == bp then
          rf = contact.extra(cp, msFG_cex1)
          af = contact.extra(cp, msFG_cex3)
          bp_other = contact.end2(cp)
        else
          rf = contact.extra(cp, msFG_cex2)
          af = contact.extra(cp, msFG_cex4)
          bp_other = contact.end1(cp)
        end_if
        if (msFG_seedID # 0) | (ball.prop( bp_other, 'msBox' ) == 'msBoxIN') then
          local theta = af + (math.degrad * ft_bRotation(bp))
          local nf = vector( math.cos(theta), math.sin(theta) )
          local xc = ball.pos(bp)   ; core center
          local xf = xc + (rf * nf) ; face center
          local tf = vector( -comp.y(nf), comp.x(nf) )   ; face tangent vector
          local Df = 2.0 * contact.prop(cp, 'fj_radius') ; face length
          local p1 = xf - (0.5 * Df * tf)
          local p2 = xf + (0.5 * Df * tf)
          _msLineA( gs, 'skirted face', p1, p2 ) ; draw face (as an edge)
          local n1 = math.unit( p1 - xc )
          local n2 = math.unit( p2 - xc )
          local p1c = xc + (radCore * n1)
          local p2c = xc + (radCore * n2)
          _msLineA( gs, 'skirted face', p1, p1c ) ; draw skirt at end1 (as an edge)
          _msLineA( gs, 'skirted face', p2, p2c ) ; draw skirt at end2 (as an edge)
          _msPoly3( gs, 'grain in skirt', xc, p1, p2 ) ; draw grain within skirt (as a polygon)
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msFGdrawSkirtedFaces3D( gs, bp, radCore )
  local rf, nfo
  loop foreach local cp ball.contactmap.all(bp)
    if contact.model(cp) == 'flatjoint' then
      if type.pointer.id(cp) == contact.typeid('ball-ball') then
        local bp_other
        if contact.end1(cp) == bp then
          rf  = contact.extra(cp, msFG_cex1)
          nfo = contact.extra(cp, msFG_cex3)
          bp_other = contact.end2(cp)
        else
          rf  = contact.extra(cp, msFG_cex2)
          nfo = contact.extra(cp, msFG_cex4)
          bp_other = contact.end1(cp)
        end_if
        if (msFG_seedID # 0) | (ball.prop( bp_other, 'msBox' ) == 'msBoxIN') then
          local nf   = vector( matrix.from.euler( math.degrad*ft_bEuler(bp) ) * nfo ) ; rotated nf
          local xc   = ball.pos(bp)                  ; core center
          local xf   = xc + (rf * nf)                ; face center
          local radF = contact.prop(cp, 'fj_radius') ; face radius
          _msDisk(  gs, 'skirted face', radF, xf, nf )              ; draw face
          _msSkirt( gs, 'skirted face', radF, xf, nf, xc, radCore ) ; draw skirt
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msCB_Make
; The contact bond plot set displays each intact grain-grain contact bond as a line.
; The line is centered at the contact location, and has length equal to the scale factor
; {msCB_sfacLen} times the distance between the centers of the two contacting pieces.
;
; INPUT: msCB_sfacLen - scale factor applied to line length (in range (0.0, 1.0])
;
  if msCB_sfacLen == 0 then ;default
    msCB_sfacLen = 0.5
  else
    if (msCB_sfacLen <= 0.0) | (msCB_sfacLen > 1.0) then
      system.error = '_msCB_Make: msCB_sfacLen must be in range (0.0, 1.0].'
    end_if
  end_if
  ;
  local gs = geom.set.find('contact bonds')
  loop foreach cp contact.list.all
    if contact.model(cp) == 'linearcbond' then
      if contact.prop(cp, 'cb_state') == 3 then
        if ft_cGrainGrain(cp) then
          if   ( _msGrainPieceInBox( cp, 1 ) ) ...
             & ( _msGrainPieceInBox( cp, 2 ) ) then
            local p1 = _msGrainPiecePt( cp, 1 )
            local p2 = _msGrainPiecePt( cp, 2 )
            _msLineB( gs, '', ...
                      msCB_sfacLen * math.mag(p2 - p1), contact.pos(cp), contact.normal(cp) )
          end_if
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msPBi_Make
; The parallel-bond interfaces plot set displays each intact grain-grain parallel bond as
; a disk with radius equal to the scale factor {msPBi_sfacRad} times the parallel-bond radius (Rbar).
; The disk is centered at the contact location and lies on the contact plane. For the 2D model,
; the parallel-bond interfaces are displayed as lines (of length 2*msPBi_sfaceRad*Rbar, and
; unit-thickness depth).
;
; INPUT: msPBi_sfacRad - scale factor applied to disk radius (in range (0.0, 1.0])
;
  if msPBi_sfacRad == 0 then ;default
    msPBi_sfacRad = 0.5  ; draw at half size, because most pbonded materials are microstructurally invalid
  else
    if (msPBi_sfacRad <= 0.0) | (msPBi_sfacRad > 1.0) then
      system.error = '_msPBi_Make: msPBi_sfacRad must be in range (0.0, 1.0].'
    end_if
  end_if
  ;
  local gs = geom.set.find('pbond interfaces')
  loop foreach cp contact.list.all
    if contact.model(cp) == 'linearpbond' then
      if contact.prop(cp, 'pb_state') == 3 then
        if ft_cGrainGrain(cp) then
          if   ( _msGrainPieceInBox( cp, 1 ) ) ...
             & ( _msGrainPieceInBox( cp, 2 ) ) then
            if global.dim == 3 then
              _msDisk( gs, '', msPBi_sfacRad * contact.prop(cp, 'pb_radius'), ...
                       contact.pos(cp), contact.normal(cp)                      )
            else ; 2D model
              local tHat = vector( -contact.normal.y(cp), contact.normal.x(cp) )
              _msLineB( gs, '', 2.0 * msPBi_sfacRad * contact.prop(cp, 'pb_radius'), ...
                        contact.pos(cp), tHat)
            end_if
          end_if
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msPBc_Make
; The parallel-bond cement plot set displays each intact grain-grain parallel bond as a
; cylinder with radius equal to the scale factor {msPBc_sfacRad} times the parallel-bond radius.
; The cylinder is centered at the contact location, and has a length equal to the scale factor
; {msPBc_sfacLen} times the distance between the centers of the two contacting pieces (Lp).
; For the 2D model, the parallel-bond cement is displayed as a rectangle
; (of width 2*msPBc_sfacRad*Rbar, length Lp, and unit-thickness depth).
;
; INPUT: msPBc_sfacRad - scale factor applied to cylinder radius (in range (0.0, 1.0])
;        msPBc_sfacLen - scale factor applied to cylinder length (in range (0.0, 1.0])
;
  if msPBc_sfacRad == 0 then ;default
    msPBc_sfacRad = 0.5
  else
    if (msPBc_sfacRad <= 0.0) | (msPBc_sfacRad > 1.0) then
      system.error = '_msPBc_Make: msPBc_sfacRad must be in range (0.0, 1.0].'
    end_if
  end_if
  ;
  if msPBc_sfacLen == 0 then ;default
    msPBc_sfacLen = 0.5
  else
    if (msPBc_sfacLen <= 0.0) | (msPBc_sfacLen > 1.0) then
      system.error = '_msPBc_Make: msPBc_sfacLen must be in range (0.0, 1.0].'
    end_if
  end_if
  ;
  local gs = geom.set.find('pbond cement')
  loop foreach cp contact.list.all
    if contact.model(cp) == 'linearpbond' then
      if contact.prop(cp, 'pb_state') == 3 then
        if ft_cGrainGrain(cp) then
          if   ( _msGrainPieceInBox( cp, 1 ) ) ...
             & ( _msGrainPieceInBox( cp, 2 ) ) then
            local Lp = msPBc_sfacLen * math.mag( _msGrainPiecePt(cp,2) - _msGrainPiecePt(cp,1) )
            if global.dim == 3 then
              _msCylinder( gs, '',                                              ...
                           msPBc_sfacRad * contact.prop(cp, 'pb_radius'), Lp, ...
                           contact.pos(cp), contact.normal(cp)                      )
            else ; 2D model
              _msLineThick2D( gs, '',                                                  ...
                              Lp, contact.pos(cp), contact.normal(cp),              ...
                              2.0 * msPBc_sfacRad * contact.prop(cp, 'pb_radius')     )
            end_if
          end_if
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msSBi_Make
; The soft-bond interfaces plot set displays each grain-grain soft-bonded contact as an
; interface. The state of the interface is based on the value of the soft-bond property
; sb_state, and can be displayed by the geometry plot item by specifying {ColorBy: Group}
; and {Sets: sbond interfaces}, with {Colors:} used to turn each entity on/off and specify
; its color. Each entity is drawn as an interface.
; The interface is drawn as a disk with radius equal to the scale factor {msSBi_sfacRad}
; times the soft-bond radius (R). The disk is centered at the contact location and lies
; on the contact plane. For the 2D model, the interface is drawn as a line (of length
; 2*msSBi_sfacRad*R, and unit-thicknes depth).
; The following entities can be displayed by setting {Colors:} to:
;    group         sb_state
;   'unbonded'     0
;   'brokeTension' 1
;   'brokeShear'   2
;   'preSoften'    3
;   'SoftPlastic'  4
;   'SoftElastic'  5
;
; INPUT: msSBi_sfacRad - scale factor applied to disk radius (in range (0.0, 1.0])
;
  if msSBi_sfacRad == 0 then ;default
    msSBi_sfacRad = 0.5  ; draw at half size, because most sbonded materials are microstructurally invalid
  else
    if (msSBi_sfacRad <= 0.0) | (msSBi_sfacRad > 1.0) then
      system.error = '_msSBi_Make: msSBi_sfacRad must be in range (0.0, 1.0].'
    end_if
  end_if
  ;
  local gs = geom.set.find('sbond interfaces')
  loop foreach cp contact.list.all
    if contact.model(cp) == 'softbond' then
      if ft_cGrainGrain(cp) then
        if   ( _msGrainPieceInBox( cp, 1 ) ) ...
          & ( _msGrainPieceInBox( cp, 2 ) ) then
          local grpName = _msSBiGrpName( contact.prop(cp, 'sb_state') )
          if global.dim == 3 then
            _msDisk( gs, grpName, msSBi_sfacRad * contact.prop(cp, 'sb_radius'), ...
                     contact.pos(cp), contact.normal(cp)                      )
          else ; 2D model
            local tHat = vector( -contact.normal.y(cp), contact.normal.x(cp) )
            _msLineB( gs, grpName, 2.0 * msSBi_sfacRad * contact.prop(cp, 'sb_radius'), ...
                      contact.pos(cp), tHat)
          end_if
        end_if
      end_if
    end_if
  end_loop
end

;------------------------------------------------
fish define _msSBiGrpName( sb_state )
  caseof sb_state
    system.error = '_msSBiGrpName: sb_state not in range 0-5'
    case 0
      _msSBiGrpName = 'unbonded'
    case 1
      _msSBiGrpName = 'brokeTension'
    case 2
      _msSBiGrpName = 'brokeShear'
    case 3
      _msSBiGrpName = 'preSoften'
    case 4
      _msSBiGrpName = 'softenPlastic'
    case 5
      _msSBiGrpName = 'softenElastic'
  endcase
end
;------------------------------------------------
fish define _msFJi_Make
; The flat-joint interfaces plot set displays the interface of each grain-grain flat-jointed
; contact. The interface, coordinate systems and discretization can be displayed by the
; geometry plot item by specifying {ColorBy: Group} and {Sets: FJ interfaces}, with {Colors:}
; used to turn each entity on/off and specify its color.
; The visualization scheme for each entity is as follows.
;   (a) Interface (group 'interface').
;       The interface is drawn as a disk with radius equal to the scale factor {msFJi_sfacRad}
;       times the flat-joint radius (R). The disk is centered at the contact location and lies
;       on the contact plane. For the 2D model, the flat-joint interface is drawn as a line
;       (of length 2*msFJi_sfaceRad*R, and unit-thickness depth).
;   (b) Coordinate systems (groups 's-tSys' and 'xi-etaSys').
;       The two coordinate systems associated with the interface (n-s-t and n-xi-eta) are drawn
;       as lines from interface center extending just beyond the interface edge, with the
;       lines in the s and xi directions being shorter than the lines in the t and eta direcs.
;       For the 2D model, the group is 'n-tSys', and only the n and t directions of the nst
;       coordinate system are drawn.
;   (c) Discretization (group 'elements').
;       The interface discretization shows elements and centroid locations. The outline of each
;       element is drawn as a set of edges, and there is a short line (aligned with the sDir)
;       at each element centroid. For the 2D model, each element is outlined by edges oriented
;       perpendicular to the interface, with a shorter perpendicular line at each element centroid.
;
; INPUT: msFJi_sfacRad - scale factor applied to disk radius (in range (0.0, 1.0])
;
  if msFJi_sfacRad == 0 then ;default
    msFJi_sfacRad = 1.0  ; draw at true size!
  else
    if (msFJi_sfacRad <= 0.0) | (msFJi_sfacRad > 1.0) then
      system.error = '_msFJi_Make: msFJi_sfacRad must be in range (0.0, 1.0].'
    end_if
  end_if
  ;
  local gs = geom.set.find('FJ interfaces')
  loop foreach cp contact.list.all
    if contact.model(cp) == 'flatjoint' then
      if ft_cGrainGrain(cp) then
        if   ( _msGrainPieceInBox( cp, 1 ) ) ...
           & ( _msGrainPieceInBox( cp, 2 ) ) then
          local radIntfc = msFJi_sfacRad * contact.prop(cp, 'fj_radius')
          _msFJiDrawIntfc(    gs, cp, radIntfc )
          _msFJiDrawCoordSys( gs, cp, radIntfc )
          _msFJiDrawDisc(     gs, cp, radIntfc )
        end_if
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _msFJiDrawIntfc( gs, cp, radIntfc )
  if global.dim == 3 then
    _msDisk( gs, 'interface', ...
             radIntfc, contact.pos(cp), contact.normal(cp) )
  else ; 2D model
    _msLineA( gs, 'interface', ...
              contact.pos(cp) + (radIntfc * _msTdir(cp)), ...
              contact.pos(cp) - (radIntfc * _msTdir(cp))      )
  end_if
end
;------------------------------------------------
fish define _msFJiDrawCoordSys( gs, cp, radIntfc )
  if global.dim == 3 then
    _msLineA( gs, 's-tSys', ...
              contact.pos(cp), ...
              contact.pos(cp) + (1.1 * radIntfc * _msSdir(  cp )) )
    _msLineA( gs, 's-tSys', ...
              contact.pos(cp), ...
              contact.pos(cp) + (1.4 * radIntfc * _msTdir(  cp )) )
    _msLineA( gs, 'xi-etaSys', ...
              contact.pos(cp), ...
              contact.pos(cp) + (1.1 * radIntfc * _msXiDir( cp )) )
    _msLineA( gs, 'xi-etaSys', ...
              contact.pos(cp), ...
              contact.pos(cp) + (1.4 * radIntfc * _msEtaDir(cp )) )
  else ; 2D model
    _msLineA( gs, 'n-tSys', ...
              contact.pos(cp), ...
              contact.pos(cp) + (0.5 * radIntfc * _msNdir(  cp )) )
    _msLineA( gs, 'n-tSys', ...
              contact.pos(cp), ...
              contact.pos(cp) + (0.5 * radIntfc * _msTdir(  cp )) )
  end_if
end
;------------------------------------------------
fish define _msFJiDrawDisc( gs, cp, radIntfc )
  if global.dim == 3 then
    _msFJiDrawDisc3D( gs, cp, radIntfc )
  else ; 2D model
    _msFJiDrawDisc2D( gs, cp, radIntfc )
  end_if
end
;##########
fish define _msFJiDrawDisc3D( gs, cp, radIntfc )
  local Nr  = contact.prop( cp, 'fj_Nr' )
  local Nal = contact.prop( cp, 'fj_Nal' )
  loop local e (1, Nr*Nal)
    contact.prop( cp, 'fj_elem' ) = e
    ;
    ;*** Draw the element.
    local del_r = radIntfc / Nr
    local del_a = (2.0 * math.pi) / Nal
    local I = math.floor( (e - 1) / Nal )
    local J = e - 1 - (I * Nal)
    local r1 = I * del_r
    local r2 = (I + 1) * del_r
    local a1 = J * del_a
    local a2 = (J + 1) * del_a
    local x1 = contact.pos(cp) + (r1 * math.cos(a1) * _msSdir(cp)) ...
                               + (r1 * math.sin(a1) * _msTdir(cp))
    local x2 = contact.pos(cp) + (r2 * math.cos(a1) * _msSdir(cp)) ...
                               + (r2 * math.sin(a1) * _msTdir(cp))
    local x3 = contact.pos(cp) + (r1 * math.cos(a2) * _msSdir(cp)) ...
                               + (r1 * math.sin(a2) * _msTdir(cp))
    local x4 = contact.pos(cp) + (r2 * math.cos(a2) * _msSdir(cp)) ...
                               + (r2 * math.sin(a2) * _msTdir(cp))
    _msLineA( gs, 'elements', x1, x2 )         ; right side
    _msLineA( gs, 'elements', x3, x4 )         ; left  side
    _msArc(   gs, 'elements', cp, r1, a1, a2 ) ; lower arc
    _msArc(   gs, 'elements', cp, r2, a1, a2 ) ; upper arc
    ;
    ;*** Draw the centroid location.
    local xCen = contact.prop( cp, 'fj_cen' )
    _msLineA( gs, 'elements', ...
              xCen - 0.02*radIntfc*_msSdir(cp), ...
              xCen + 0.02*radIntfc*_msSdir(cp) )
  end_loop
end
;##########
fish define _msFJiDrawDisc2D( gs, cp, radIntfc )
  local Nr  = contact.prop( cp, 'fj_Nr' )
  loop local e (1, Nr)
    contact.prop( cp, 'fj_elem' ) = e
    ;
    ;*** Draw the element.
    local lenHalf = radIntfc / Nr
    local xCen = contact.prop( cp, 'fj_cen' )
    local xLt = xCen - (lenHalf * _msTdir(cp))
    local xRt = xCen + (lenHalf * _msTdir(cp))
    _msLineA( gs, 'elements', ...                     ; left  side
              xLt - 0.08*radIntfc*_msNdir(cp), ...
              xLt + 0.08*radIntfc*_msNdir(cp) )
    _msLineA( gs, 'elements', ...                     ; right side
              xRt - 0.08*radIntfc*_msNdir(cp), ...
              xRt + 0.08*radIntfc*_msNdir(cp) )
    ;
    ;*** Draw the centroid location.
    _msLineA( gs, 'elements', ...
              xcen, xcen + 0.08*radIntfc*_msNdir(cp) )
  end_loop
end

;------------------------------------------------
fish define _msCK_Make
; The crack plot set displays the cracks with thickness proportional to gap. The cracks and gap
; are taken from the crack-monitoring package. Cracks are drawn as thick disks for the 3D model,
; and thick lines of unit-thickness depth for the 2D model. The crack size is taken as the scale
; factor (msCK_sfacSize) times the size returned by the crack-monitoring package. The cracks can
; be displayed by the geometry plot item by specifying {ColorBy: Group}, {Sets: cracks}, and
; {Polys: checked}, with {Colors:} used to turn each entity (crack type and failure mode) on/off
; and specify its color. Filtered cracks can be displayed by setting msCK_ckFilter to true.
; Ghost cracks, defined as the cracks for which the originating contact no longer exists, are
; not displayed. Only grain-grain cracks with both parent grains inside of the microstructural
; box are drawn.
;
; Crack thickness is equal to the true gap, with the restriction that the thickness lies in the
; range of [tMin, tMax] where {tMin, tMax} = avgSize * msCK_sfac{MinThick, MaxThick}, with
; avgSize equal to the average size of all displayed cracks. To draw all cracks with thickness
; equal to the positive gap (and minimum thickness for cracks with negative gap), set
; msCK_sfacMaxThick = 1e20 (the default value).
;
; INPUT: ckInited
;        msCK_sfacSize     - scale factor applied to crack size (in range (0.0, 1.0])
;        msCK_sfacMinThick - scale factor applied to avgSize to give min thickness (in (0.0, 1.0])
;        msCK_sfacMaxThick - scale factor applied to avgSize to give max thickness (positive)
;        msCK_ckFilter     - if true, then display only filtered cracks (default is false)
;                            (command: [msCK_ckFilter = true])
;
  if ckInited == false then
    io.out('_msCK_Make: The crack-monitoring package is not active, no cracks to plot.')
    exit
  else
    ckForceUpdate
  end_if
  ;
  if msCK_sfacSize == 0 then ;default
    msCK_sfacSize = 1.0
  else
    if (msCK_sfacSize <= 0.0) | (msCK_sfacSize > 1.0) then
      system.error = '_msCK_Make: msCK_sfacSize must be in range (0.0, 1.0].'
    end_if
  end_if
  if msCK_sfacMinThick == 0 then ;default
    msCK_sfacMinThick = 0.03
  else
    if (msCK_sfacMinThick <= 0.0) | (msCK_sfacMinThick > 1.0) then
      system.error = '_msCK_Make: msCK_sfacMinThick must be in range (0.0, 1.0].'
    end_if
  end_if
  if msCK_sfacMaxThick == 0 then ;default
    msCK_sfacMaxThick = 1e20
  else
    if msCK_sfacMaxThick <= 0.0 then
      system.error = '_msCK_Make: msCK_sfacMaxThick must be positive.'
    end_if
  end_if
  ;
  local gs = geom.set.find('cracks')
  local ckDFN = ckGetDFN
  local avgSize = _msCKAvgSize( ckDFN )
  loop foreach local myCrk dfn.fracturelist( ckDFN )
    if _msCKdrawMe( myCrk ) == false then
      continue
    end_if
    ;
    local grpName
    if msCK_ckFilter == true then
      grpName = fracture.group( myCrk, 2 )
    else
      grpName = fracture.group( myCrk, 1 )
    end_if
    local size  = ckGetSize( myCrk )
    local pos   = fracture.pos( myCrk )
    local nDir  = fracture.normal( myCrk )
    local gap   = fracture.extra( myCrk, 5 )
    local thick = _msCKthick( gap, ...
                              msCK_sfacMinThick*avgSize, ...
                              msCK_sfacMaxThick*avgSize      )
    if global.dim == 3 then
      _msCylinder( gs, grpName, ...
                   0.5*msCK_sfacSize*size, thick, pos, nDir )
      local posTop = pos + 0.5*thick*nDir
      local posBot = pos - 0.5*thick*nDir
      _msDisk( gs, grpName, ...
               0.5*msCK_sfacSize*size, posBot, nDir )
      _msDisk( gs, grpName, ...
               0.5*msCK_sfacSize*size, posTop, nDir )
    else ; 2D model
      local tHat = vector( -comp.y(nDir), comp.x(nDir) ) ; nDir cross tHat = +kHat
      _msLineThick2D( gs, grpName, ...
                      msCK_sfacSize*size, pos, tHat, thick)
    end_if
  end_loop
end
;------------------------------------------------
fish define _msCKdrawMe( myCrk )
  local drawMe = true
  local cp = fracture.extra( myCrk, 1 )
  if cp # null then
    if   (ft_cGrainGrain(cp) == false) ...
       | ( _msGrainPieceInBox( cp, 1 ) == false ) ...
       | ( _msGrainPieceInBox( cp, 2 ) == false ) then
       drawMe = false
    end_if
  else ; ghost crack
    drawMe = false
  end_if
  _msCKdrawMe = drawMe
end
;------------------------------------------------
fish define _msCKAvgSize( ckDFN )
; Return the average size of all displayed cracks.
;
; PARAM: pointer to the CrackData-DFN
;
  local cnt = 0, sumSize = 0.0
  loop foreach local myCrk dfn.fracturelist( ckDFN )
    if _msCKdrawMe( myCrk ) == true then
      cnt = cnt + 1
      sumSize = sumSize + ckGetSize( myCrk )
    end_if
  end_loop
  if cnt > 0 then
    _msCKAvgSize = sumSize / cnt
  else
    _msCKAvgSize = 0.0
  end_if
end
;------------------------------------------------
fish define _msCKthick( gap, minThick, maxThick )
; Return the thickness of the gap-based crack with a given gap (may be negative).
; The thickness will be in range [minThick, maxThick].
;
; PARAMS: see header
;
  local thick = gap
  if thick <= 0.0 then
    thick = minThick
  else if thick >= maxThick then
    thick = maxThick
  end_if
  _msCKthick = thick
end
;------------------------------------------------
fish define _msNdir( cp )  ; Contact-plane normal direction
  _msNdir = contact.normal(cp)
end
;##########
fish define _msSdir( cp ) ; Contact-plane coord. system (s axis)
  if global.dim == 3 then
    _msSdir = contact.shear(cp)
  else ; 2D model
    system.error = '_msSdir cannot be called for 2D model, note that _msSdir is -k_hat.'
  end_if
end
;##########
fish define _msTdir( cp ) ; Contact-plane coord. system (t axis)
  if global.dim == 3 then
    _msTdir = math.cross( _msNdir(cp), _msSdir(cp) )
  else ; 2D model
    _msTdir = contact.shear(cp)
  end_if
end
;##########
fish define _msXiDir( cp ) ; 3D flat-joint interface n-xi-eta system (xi axis)
  if contact.model(cp) # 'flatjoint' then
    system.error = '_msXiDir operating on a non flat-jointed contact.'
  end_if
  ;
  if global.dim == 3 then
    local relbrS = comp.x( contact.prop( cp, 'fj_relbr' ) )
    local relbrT = comp.y( contact.prop( cp, 'fj_relbr' ) )
    local XiDir =   relbrS * _msSdir(cp) ...
                  + relbrT * _msTdir(cp)
    _msXiDir = math.unit( XiDir )
  else ; 2D model
     system.error = '_msXiDir not yet implemented for 2D model'
  end_if
end
;##########
fish define _msEtaDir( cp ) ; 3D flat-joint interface n-xi-eta system (eta axis)
  if contact.model(cp) # 'flatjoint' then
    system.error = '_msEtaDir operating on a non flat-jointed contact.'
  end_if
  ;
  if global.dim == 3 then
    _msEtaDir = math.unit( math.cross( _msNdir(cp), _msXidir(cp) ) )
  else ; 2D model
     system.error = '_msEtaDir not yet implemented for 2D model'
  end_if
end
;------------------------------------------------
fish define _msPoly3( gs, gn, P1, P2, P3 )
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   Pi - cyclically ordered points, i = {1,2,3} [VEC]
; The 3-sided polygon is defined by its three cyclically ordered points {Pi}.
; The 3-sided polygon is stored as a polygon in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygon.
;
  local poly = geom.poly.create( gs )
  geom.poly.add.node( gs, poly, P1 )
  geom.poly.add.node( gs, poly, P2 )
  geom.poly.add.node( gs, poly, P3 )
  geom.poly.close( gs, poly )
  ;
  if gn # '' then
    geom.poly.group( poly, 1 ) = gn
  end_if
end
;------------------------------------------------
fish define _msPoly4( gs, gn, P1, P2, P3, P4 )
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   Pi - cyclically ordered points, i = {1,2,3,4} [VEC]
; The 4-sided polygon is defined by its four cyclically ordered points {Pi}.
; The 4-sided polygon is stored as a polygon in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygon.
;
  local poly = geom.poly.create( gs )
  geom.poly.add.node( gs, poly, P1 )
  geom.poly.add.node( gs, poly, P2 )
  geom.poly.add.node( gs, poly, P3 )
  geom.poly.add.node( gs, poly, P4 )
  geom.poly.close( gs, poly )
  ;
  if gn # '' then
    geom.poly.group( poly, 1 ) = gn
  end_if
end
;------------------------------------------------
fish define _msLineA( gs, gn, p1, p2 )
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   p1 - line end1 position
;   p2 - line end2 position
; The line is defined by its two end points, and directed from p1 to p2.
; The line is stored as an edge in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new edge.
;
  local edge = geom.edge.create( gs, ...
                                 geom.node.create( gs, p1 ), ...
                                 geom.node.create( gs, p2 )      )
  if (gn # '') & (edge # null) then
    geom.edge.group( edge, 1 ) = gn
  end_if
end
;------------------------------------------------
fish define _msLineB( gs, gn, ll, xl, nl )
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   ll - line length
;   xl - line center
;   nl - line axis unit-normal
; The line is defined by its length {ll}, center {xl} and axis unit-normal {nl}.
; The line is stored as an edge in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new edge.
;
  local p1 = xl - (0.5 * ll * nl)
  local p2 = xl + (0.5 * ll * nl)
  _msLineA( gs, gn, p1, p2 )
end
;------------------------------------------------
fish define _msArc( gs, gn, cp, ra, a1, a2 ) ; PFC3D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   cp - contact pointer (assumed to be a flat-jointed contact)
;   ra - arc radius
;   a1 - starting angle (wrt s direction, a2 > a1)
;   a2 - ending angle   (wrt s direction, a2 > a1)
; The arc lies on the interface of a flat-jointed contact, and is defined wrt the interface
; center.
; The arc is stored as a collection of edges in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new edges.
;
  if global.dim == 2 then
    system.error = '_msArc: PFC3D only.'
  end_if
  ;
  local nSeg = 4 ; number of segments defining arc perimeter
  local delAlpha = (a2 - a1) / nSeg
  loop for( local i=1, i<=nSeg, i=i+1 )
    local al1 = a1 + ((i - 1) * delAlpha)
    local al2 = a1 + ((i    ) * delAlpha)
    local p1 = contact.pos(cp) + (ra * math.cos(al1) * _msSdir(cp)) ...
                               + (ra * math.sin(al1) * _msTdir(cp))
    local p2 = contact.pos(cp) + (ra * math.cos(al2) * _msSdir(cp)) ...
                               + (ra * math.sin(al2) * _msTdir(cp))
    local edge = geom.edge.create( gs, ...
                                   geom.node.create( gs, p1 ), ...
                                   geom.node.create( gs, p2 )      )
    if (gn # '') & (edge # null) then
      geom.edge.group( edge, 1 ) = gn
    end_if
  end_loop
end
;------------------------------------------------
fish define _msDisk( gs, gn, rd, xd, nd ) ; PFC3D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   rd - disk radius
;   xd - disk center
;   nd - disk unit-normal
; The zero-thickness disk is defined by its radius {rd}, center {xd} and unit-normal {nd}.
; The disk is stored as a polygon in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygon.
;
  if global.dim == 2 then
    system.error = '_msDisk: PFC3D only.'
  end_if
  ;
  local nSeg = 20 ; number of segments defining disk perimeter (nSeg >= 3)
  local sHat = _msLocalS( nd )
  local tHat = math.cross( nd, sHat )
  ;
  local poly = geom.poly.create( gs )
  local delTheta = 2.0 * math.pi / nSeg
  loop for( local i=1, i<=nSeg, i=i+1 )
    local theta = (i - 1) * delTheta
    local P = xd + (rd * math.cos(theta)) * sHat ...
                 + (rd * math.sin(theta)) * tHat
    local edge = geom.poly.add.node( gs, poly, P )
  end_loop
  edge = geom.poly.close( gs, poly )
  ;
  if gn # '' then
    geom.poly.group( poly, 1 ) = gn
  end_if
end
;------------------------------------------------
fish define _msSkirt( gs, gn, rd, xd, nd, xc, rc ) ; PFC3D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   rd - disk radius
;   xd - disk center
;   nd - disk unit-normal
;   xc - spherical core center
;   rc - spherical core radius
; The skirt surrounds the zero-thickness disk that is defined by its radius {rd}, center {xd}
; and unit-normal {nd}. The skirt surface consists of edges that are projected from the disk
; edge to the core center, and truncated at the core surface.
; The skirt is stored as a collection of polygons in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygons.
;
  if global.dim == 2 then
    system.error = '_msSkirt: PFC3D only.'
  end_if
  ;
  local nSeg = 20 ; number of segments defining skirt perimeter (nSeg >= 3)
  local sHat = _msLocalS( nd )
  local tHat = math.cross( nd, sHat )
  ;
  local poly = geom.poly.create( gs )
  local delTheta = 2.0 * math.pi / nSeg
  loop for( local i=1, i<=nSeg, i=i+1 )
    local theta1 = (i - 1) * delTheta
    local theta2 =  i      * delTheta
    local P1 = xd + (rd * math.cos(theta1)) * sHat ...
                  + (rd * math.sin(theta1)) * tHat
    local P2 = xd + (rd * math.cos(theta2)) * sHat ...
                  + (rd * math.sin(theta2)) * tHat
    local nc, lc
    nc = math.unit( xc - P1 )
    lc = math.mag(  xc - P1 )
    local P1proj = P1 + ((lc - rc) * nc)
    nc = math.unit( xc - P2 )
    lc = math.mag(  xc - P2 )
    local P2proj = P2 + ((lc - rc) * nc)
    _msPoly4( gs, gn, P1, P2, P2proj, P1proj )
  end_loop
end
;------------------------------------------------
fish define _msCylinder( gs, gn, rc, lc, xc, nc ) ; PFC3D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   rc - cylinder radius (rc > 0)
;   lc - cylinder length (lc > 0)
;   xc - cylinder center
;   nc - cylinder axis unit-normal
; The open-ended cylinder is defined by its radius {rc}, length {lc}, center {xc} and unit-normal {nc}.
; The open-ended cylinder is stored as a collection of polygons in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygons.
;
  if global.dim == 2 then
    system.error = '_msCylinder: PFC3D only.'
  end_if
  ;
  local nSeg = 20 ; number of segments defining cylinder perimeter (nSeg >= 3)
  local sHat = _msLocalS( nc )
  local tHat = math.cross( nc, sHat )
  ;
  local delTheta = 2.0 * math.pi / nSeg
  loop for( local i=1, i<=nSeg, i=i+1 )
    local theta0 = (i - 1) * delTheta
    local theta1 =       i * delTheta
    local P1 = (xc - 0.5*lc*nc) + (rc * math.cos(theta0)) * sHat ...
                                + (rc * math.sin(theta0)) * tHat     ; first  bottom disk point
    local P2 = (xc - 0.5*lc*nc) + (rc * math.cos(theta1)) * sHat ...
                                + (rc * math.sin(theta1)) * tHat     ; second bottom disk point
    local P3 = (xc + 0.5*lc*nc) + (rc * math.cos(theta1)) * sHat ...
                                + (rc * math.sin(theta1)) * tHat     ; second top    disk point
    local P4 = (xc + 0.5*lc*nc) + (rc * math.cos(theta0)) * sHat ...
                                + (rc * math.sin(theta0)) * tHat     ; first  top    disk point
    local poly = geom.poly.create( gs )
    geom.poly.add.node( gs, poly, P1 )
    geom.poly.add.node( gs, poly, P2 )
    geom.poly.add.node( gs, poly, P3 )
    geom.poly.add.node( gs, poly, P4 )
    geom.poly.close(    gs, poly     )
    if gn # '' then
      geom.poly.group( poly, 1 ) = gn
    end_if
  end_loop
end
;------------------------------------------------
fish define _msSphere( gs, gn, xs, rs ) ; PFC3D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   xs - sphere center
;   rs - sphere radius
; The sphere is defined by its center {xs} and radius {rs}.
; The sphere is stored as a collection of polygons in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygons.
;
; Spherical coordinates (r, theta, phi):
;   x = r*sin(theta)*cos(phi), y = r*sin(theta)*sin(phi), z = r*cos(theta)
;   with r >= 0, 0 <= theta <= pi, 0 <= phi < 2*pi.
;   North Pole at (r, 0, phi), South Pole at (r, pi, phi)
;
  if global.dim == 2 then
    system.error = '_msSphere: PFC3D only.'
  end_if
  ;
  local nFac = 60 ; number of facets around sphere equator (nFac is even, >= 8)
  ;
  local del_theta = 2.0 * math.pi / nFac
  local del_phi   = del_theta
  local tLast = 0.5*nFac
  loop for( local t=1, t<=tLast, t=t+1 )
    loop for( local p=1, p<=nFac, p=p+1 )
      local theta0 = (t-1) * del_theta
      local theta1 =     t * del_theta
      local phi0 = (p-1) * del_phi
      local phi1 =     p * del_phi
      local P1 = vector( comp.x(xs) + rs * math.sin(theta0) * math.cos(phi0), ...
                         comp.y(xs) + rs * math.sin(theta0) * math.sin(phi0), ...
                         comp.z(xs) + rs * math.cos(theta0)                       )
      local P2 = vector( comp.x(xs) + rs * math.sin(theta0) * math.cos(phi1), ...
                         comp.y(xs) + rs * math.sin(theta0) * math.sin(phi1), ...
                         comp.z(xs) + rs * math.cos(theta0)                       )
      local P3 = vector( comp.x(xs) + rs * math.sin(theta1) * math.cos(phi1), ...
                         comp.y(xs) + rs * math.sin(theta1) * math.sin(phi1), ...
                         comp.z(xs) + rs * math.cos(theta1)                       )
      local P4 = vector( comp.x(xs) + rs * math.sin(theta1) * math.cos(phi0), ...
                         comp.y(xs) + rs * math.sin(theta1) * math.sin(phi0), ...
                         comp.z(xs) + rs * math.cos(theta1)                       )

      if      (t == 1    ) then ; theta0 is North Pole, P1 = P2
        _msPoly3( gs, gn, P2, P3, P4 )
      else if (t == tLast) then ; theta1 is South Pole, P3 = P4
        _msPoly3( gs, gn, P1, P2, P3 )
      else
        _msPoly4( gs, gn, P1, P2, P3, P4 )
      end_if
    end_loop
  end_loop
end
;------------------------------------------------
fish define _msLineThick2D( gs, gn, ll, xl, nl, tl ) ; PFC2D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   ll - line length
;   xl - line center
;   nl - line axis unit-normal (in direction of line length)
;   tl - line thickness
; The line is defined by its length {ll}, center {xl}, axis unit-normal {nl} and thickness {tl}.
; The line is stored as a polygon in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygon.
;
;               ^ tHat
;  4            |            3
;  *-------------------------*
;  |                         |
;  |            *xl          |---> nl
;  |                         |
;  *-------------------------*
;  1                         2
;
  if global.dim == 3 then
    system.error = '_msLineThick2D: PFC2D only.'
  end_if
  ;
  local poly = geom.poly.create( gs )
  local tHat = vector( -comp.y(nl), comp.x(nl) )  ; nl cross tHat = +kHat
  local P1 = xl - (0.5 * ll * nl) - (0.5 * tl * tHat)
  local P2 = xl + (0.5 * ll * nl) - (0.5 * tl * tHat)
  local P3 = xl + (0.5 * ll * nl) + (0.5 * tl * tHat)
  local P4 = xl - (0.5 * ll * nl) + (0.5 * tl * tHat)
  geom.poly.add.node( gs, poly, P1 )
  geom.poly.add.node( gs, poly, P2 )
  geom.poly.add.node( gs, poly, P3 )
  geom.poly.add.node( gs, poly, P4 )
  geom.poly.close(    gs, poly     )
  ;
  if gn # '' then
    geom.poly.group( poly, 1 ) = gn
  end_if
end
;------------------------------------------------
fish define _msCircle2D( gs, gn, xc, rc ) ; PFC2D only
; PARAMS:
;   gs - geometry set pointer
;   gn - group name (in slot 1)
;   xc - circle center
;   rc - circle radius
; The circle is defined by its center {xc} and radius {rc}.
; The circle is stored as a polygon in the geometry set {gs}.
; If the group name is not empty, then assign the group name to the new polygon.
;
  if global.dim == 3 then
    system.error = '_msCircle2D: PFC2D only.'
  end_if
  ;
  local nSeg = 30 ; number of segments around circle perimeter (nSeg >= 3)
                  ; 30 gives approx. same resolution as ball plot item
  ;
  local poly = geom.poly.create( gs )
  local delTheta = 2.0 * math.pi / nSeg
  loop for( local i=1, i<=nSeg, i=i+1 )
    local theta = (i - 1) * delTheta
    local P = vector( comp.x(xc) + rc * math.cos(theta), ...
                      comp.y(xc) + rc * math.sin(theta)      )
    geom.poly.add.node( gs, poly, P )
  end_loop
  geom.poly.close( gs, poly )
  ;
  if gn # '' then
    geom.poly.group( poly, 1 ) = gn
  end_if
end
;------------------------------------------------
fish define _msGrainPieceInBox( cp, eNum )
; Return true if the piece at end {eNum = 1 or 2} of the two contacting grain pieces
; is in the microstructural box; otherwise, return false.
  local pInBox = false
  if eNum == 1 then
    local end1 = contact.end1(cp)
    if type.pointer.id( end1 ) == ball.typeid then ; end1 is a ball
      pInBox = (        ball.prop( end1, 'msBox' ) == 'msBoxIN')
    else                                           ; end1 is a pebble
      pInBox = (clump.pebble.prop( end1, 'msBox' ) == 'msBoxIN')
    end_if
  else if eNum == 2 then
    local end2 = contact.end2(cp)
    if type.pointer.id( end2 ) == ball.typeid then ; end2 is a ball
      pInBox = (        ball.prop( end2, 'msBox' ) == 'msBoxIN')
    else                                           ; end2 is a pebble
      pInBox = (clump.pebble.prop( end2, 'msBox' ) == 'msBoxIN')
    end_if
  else
    system.error = '_msGrainPieceInBox: eNum is not 1 or 2.'
  end_if
  _msGrainPieceInBox = pInBox
end
;------------------------------------------------
fish define _msGrainPiecePt( cp, eNum )
; Return center {pOut} of the piece at end {eNum = 1 or 2} of the two contacting grain pieces
; joined by contact {cp}. A grain piece is a ball or pebble.
;
  local pOut
  if eNum == 1 then
    local end1 = contact.end1(cp)
    if type.pointer.id( end1 ) == ball.typeid then ; end1 is a ball
      pOut = ball.pos( end1 )
    else                                           ; end1 is a pebble
      pOut = clump.pebble.pos( end1 )
    end_if
  else if eNum == 2 then
    local end2 = contact.end2(cp)
    if type.pointer.id( end2 ) == ball.typeid then ; end2 is a ball
      pOut = ball.pos( end2 )
    else                                           ; end2 is a pebble
      pOut = clump.pebble.pos( end2 )
    end_if
  else
    system.error = '_msGrainPiecePt: eNum is not 1 or 2.'
  end_if
  _msGrainPiecePt = pOut
end
;------------------------------------------------
fish define _msLocalS( np )
; Return unit vector {sHat} that is aligned with projection of global x or y direction
; onto the plane with unit normal {np} (whichever is not parallel with {np}).
;
  local sHat
  local iHat = vector( 1.0, 0.0, 0.0 )
  local jHat = vector( 0.0, 1.0, 0.0 )
  if math.mag( math.cross( iHat, np ) ) >= _ftCheckZeroTol then
    sHat = iHat - math.dot( iHat, np ) * np
  else
    sHat = jHat - math.dot( jHat, np ) * np
  end_if
  sHat = math.unit( sHat )
  _msLocalS = sHat
end
;************************************************
; Support at FishTank level, public functions: ft_X, private functions: _ftX.
; Function groupings:
;   Related to material: ft_mX
;   Operate on    balls: ft_bX(bp)
;   Operate on   clumps: ft_clX(cl)
;   Operate on contacts: ft_cX(cp)
;------------------------------------------------
fish define _ftCodeDependencies
; Include functions that will only work with either PFC2D or PFC3D, because they contain Fish intrinsics
; that are specific to each code.
  if global.dim == 3 then
    command
      fish define ft_bEuler( bp )
        ft_bEuler = ball.euler(bp)
      end
    end_command
  else ; 2D model
    command
      fish define ft_bRotationSet( bp, rot )
        ball.rotation(bp) = rot
      end
      fish define ft_bRotation( bp )
        ft_bRotation = ball.rotation(bp)
      end
    end_command
  end_if
end
@_ftCodeDependencies
;------------------------------------------------
fish define _ftInit
  ft_cexNum = 0 ; number of extra slots associated with contacts
end
@_ftInit
;------------------------------------------------
fish define _ftConstants
  _ftOneThird = 1.0/3.0
  _ftOneSixth = 1.0/6.0
  _ftCheckZeroTol = 1e-6
end
@_ftConstants
;------------------------------------------------
fish define _ftModulus( i, n )
; Return modulus of i with n (C++ notation is i % n), i and n are INTs.
; The expression _ftModulus(i,n) produces the remainder when i is divided by n,
; and thus is zero when n divides i exactly.
;
  i = int(i)
  n = int(n)
  if i == n * (i/n) then
    _ftModulus = 1
  else
    _ftModulus = 0
  end_if
end
;------------------------------------------------
fish define _ftAng2D( vec2D ) ; PFC2D only
; Return the angle (in radians) of the 2D vector measured ccw wrt +x-axis.
; The angle will be in range [0, 2*pi].
  angOut = math.atan2( comp.y(vec2D), comp.x(vec2D) )
  if angOut < 0.0 then
    angOut = angOut + 2.0*math.pi
  end_if
  _ftAng2D = angOut
end
;------------------------------------------------
fish define _ftAngMin( V1, V2, Vsize )
; Return the minimum angle (in radians) between V1 and V2, minAng in [0, 180].
;   tan( min_angle ) = mag( V1 cross V2 ) / mag( V1 dot V2 )
; PARAMS:
;   V1    - vector 1
;   V2    - vector 2
;   Vsize - size of V1 and V2 (must be 2 or 3)
;
  if Vsize < 2 | Vsize > 3 then
    system.error = '_ftAngMin: argument Vsize is not 2 or 3.'
  end_if
  ;
  local numer
  if Vsize == 3 then
    numer = math.mag( math.cross( V1, V2 ) )
  else  ; Vsize == 2
    numer = math.abs( math.cross( V1, V2 ) ) ; math.cross returns scalar, if args are size 2
  end_if
  local denom = math.dot( V1, V2 )
  ;
  _ftAngMin = math.atan2( numer, denom )
end
; --------------------------------------------
fish define ft_SaveState( runName, tagName )
; Create save state with file name [ <runName>-<tagName>.p{2,3}sav ].
; The file is saved to the current directory.
;   For example, given PFC3D, runName of 'myRun' and tagName of 'myTag',
;   the file name will be: 'myRun-myTag.p3sav'.
;
  local fName = string(runName) + '-' + string(tagName)
        fName = fName + '.p' + string(global.dim) + 'sav'
  command
    model save [fName] localdir
  end_command
end
;------------------------------------------------
fish define ft_SetTitle( titStr )
  command
    model title [titStr]
  end_command
end
;------------------------------------------------
fish define ft_valNormDist( mean, sdev )
; Return a non-negative value from a normal distribution with
; given mean and standard deviation.
;
  loop while 1 # 0
    local _val = mean + (math.random.gauss * sdev)
    if _val >= 0.0 then
      ft_valNormDist = _val
      exit
    end_if
  end_loop
end
;------------------------------------------------
fish define ft_eq( ARatLimit, stepLimit )
; Cycle the model until a state of static equilibrium is obtained. Cycling continues until
; either the mechanical ratio-average falls below the equilibrium-ratio limit or
; the number of steps exceeds the equilibrium-step limit.
; PARAMS:
;   ARatLimit : equilibrium-ratio limit (for {model solve ratio-average} command)
;   stepLimit : equilibrium-step limit  (for {model solve cycles}        command)
; Returns:
;   0 : equilibrium-ratio limit met
;   1 : equilibrium-step limit reached before equilibrium-ratio limit met
;
  local myStr = '** ft_eq (entering with parameters:'
  myStr = myStr + ' ARatLimit: '+string(ARatLimit)+','
  myStr = myStr + ' stepLimit: '+string(stepLimit)+')'
  io.out( myStr )
  ;
  command
    model cycle 1  ; set up those limits before invoking {model solve}
    model solve ratio-average [ARatLimit] cycles [stepLimit]
  end_command
  local returnCode
  if mech.solve( 'ratio-average' ) <= ARatLimit then
    returnCode = 0
  else
    returnCode = 1
  end_if
  ;
  myStr = '** ft_eq (exiting with condition: '
  if returnCode == 0 then
    myStr = myStr + 'ARatLimit met)'
  else
    myStr = myStr + 'stepLimit reached, but ARatLimit not met)'
  end_if
  myStr = myStr + ' [Mech Aratio: '+string( mech.solve('ratio-average') )+']'
  io.out( myStr )
  ;
  ft_eq = returnCode
end
;------------------------------------------------
fish define ft_OverlapRatios
; Compute overlap ratios of all active contacts, and then return maximum, minimum and average values.
; The OR is the overlap divided by the piece diameter. For grain-grain contacts, there are
; two ORs, while for grain-wall contacts, there is one OR.
;
; OUT: mp_OR{max,min,avg}
;
  mp_ORmax = -1.0e20
  mp_ORmin =  1.0e20
  mp_ORavg =  0.0
  local cntOR = 0
  local sumOR = 0.0
  local  pieceRad1, pieceRad2
  loop foreach local cp contact.list
    if      type.pointer.id(cp) == contact.typeid('ball-ball')     then
      pieceRad1 = ball.radius( contact.end1(cp) )
      pieceRad2 = ball.radius( contact.end2(cp) )
    else if type.pointer.id(cp) == contact.typeid('ball-pebble')   then
      pieceRad1 = ball.radius( contact.end1(cp) )
      pieceRad2 = clump.pebble.radius( contact.end2(cp) )
    else if type.pointer.id(cp) == contact.typeid('ball-facet')    then
      pieceRad1 = ball.radius( contact.end1(cp) )
      pieceRad2 = 0.0
    else if type.pointer.id(cp) == contact.typeid('pebble-pebble') then
      pieceRad1 = clump.pebble.radius( contact.end1(cp) )
      pieceRad2 = clump.pebble.radius( contact.end2(cp) )
    else if type.pointer.id(cp) == contact.typeid('pebble-facet')  then
      pieceRad1 = clump.pebble.radius( contact.end1(cp) )
      pieceRad2 = 0.0
    else
      system.error = 'ft_OverlapRatios: Undefined contact type.'
    end_if
    ;
    local curOR
    local overlap = -contact.gap(cp)
    if pieceRad1 # 0.0 then
      curOR = overlap / (2.0*pieceRad1)
      mp_ORmax = math.max( curOR, mp_ORmax )
      mp_ORmin = math.min( curOR, mp_ORmin )
      cntOR = cntOR + 1
      sumOR = sumOR + curOR
    end_if
    ;
    if pieceRad2 # 0.0 then
      curOR = overlap / (2.0*pieceRad2)
      mp_ORmax = math.max( curOR, mp_ORmax )
      mp_ORmin = math.min( curOR, mp_ORmin )
      cntOR = cntOR + 1
      sumOR = sumOR + curOR
    end_if
  end_loop
  ;
  if cntOR # 0 then
    mp_ORavg = float(sumOR) / float(cntOR)
  end_if
end
;------------------------------------------------
fish define ft_setMatBehavior( cSet, prox, fric )
; Virtual function to set material behavior for existing and future grain-grain contacts
; to be that of a given material.
;
; PARAMS:
;   cSet : contact set ('existing', 'future') to which properties will be assigned [string]
;          Future contacts are those that may form during subsequent motion.
;   prox : insure that contacts will be created for pieces within this distance of one another [float]
;          If cSet == 'future' then use this parameter.
;   fric : friction coefficient [float]
;          If fric == -99.0 then use the material property; otherwise, use this parameter.
;
; IN (material properties, one of which is friction coefficient):
;   To be provided by redefined function.
;
  system.error = 'The FISH function ft_setMatBehavior is a virtual function that must be redefined.'
end
;------------------------------------------------
fish define ft_setMatBehavior( cSet, prox, fric )
; Redefined function to set material behavior for existing and future grain-grain contacts
; to be that of the linear material.
;
; PARAMS (see virtual function ft_setMatBehavior)
;
; IN (material properties, one of which is friction coefficient):
;   lnm_emod : effective modulus [float]
;   lnm_krat : stiffness ratio [float]
;   lnm_fric : friction coefficient [float]
;
  local cmName
  if      cm_matType == 0 then ; linear material
    cmName = 'linear'
  else if cm_matType == 1 then ; contact-bonded material
    cmName = 'linearcbond'
  else if cm_matType == 2 then ; parallel-bonded material
    cmName = 'linearpbond'
  else if cm_matType == 3 then ; soft-bonded material
    cmName = 'linear'
  else if cm_matType == 4 then ; flat-jointed material
    cmName = 'linear'
  else                         ; user-defined material
    system.error = 'A redefined ft_setMatBehavior must be provided for user-defined material.'
  end_if
  ;
  local theFric
  if fric == -99.0 then
    theFric = lnm_fric
  else
    theFric = fric
  end_if
  _mpSetEffLinBehavior( cSet, prox, lnm_emod, lnm_krat, theFric, 'grain-grain', cmName )
end
;------------------------------------------------
fish define ft_setGrainWallBehavior( cSet, prox, emod, krat, fric, cmName )
; Set material behavior for existing and future grain-wall contacts to be that of
; a linear-based material.
; PARAMS:
;   {cSet, prox, emod, krat, fric} : see ft_setMatBehavior
;   cmName : see _mpSetEffLinBehavior
;
  _mpSetEffLinBehavior( cSet, prox, emod, krat, fric, 'grain-wall', cmName )
end
;------------------------------------------------
fish define ft_SmoothGrainWallInterface
; For all grain-wall contacts with a negative contact gap, set the reference gap equal to
; the contact gap. This will establish reference surfaces that are just touching and effectively
; remove the overlap --- as if we cut off the part of each ball or pebble that protrudes outside
; of the wall.
;
  loop foreach local cp contact.list.all
    if ft_cGrainWall(cp) then
      if contact.gap(cp) < 0.0 then
        contact.prop(cp, 'rgap') = contact.gap(cp) ; remove overlap
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define ft_ZeroGrainDisplacement
  if global.dim == 3 then
    if ball.num > 0 then
      command
        ball  attribute displacement (0.0,0.0,0.0)
      end_command
    end_if
    if clump.num > 0 then
      command
        clump attribute displacement (0.0,0.0,0.0)
      end_command
    end_if
  else ; 2D model
    if ball.num > 0 then
      command
        ball  attribute displacement (0.0,0.0)
      end_command
    end_if
    if clump.num > 0 then
      command
        clump attribute displacement (0.0,0.0)
      end_command
    end_if
  end_if
end
;------------------------------------------------
fish define ft_mBonded
; Return true if a bonded material is being created.
  if   (cm_matType == 1) | (cm_matType == 2) ...
     | (cm_matType == 3) | (cm_matType == 4) then
    ft_mBonded = true
  else
    ft_mBonded = false
  end_if
end
;------------------------------------------------
fish define ft_bNumBond( bp )
; Return number of intact bonds of ball bp.
;
  if ft_mBonded then ; bonded material
    local numBond = 0
    loop foreach local cp ball.contactmap(bp)
      case_of cm_matType
        case 1 ; contact-bonded material
          if contact.model(cp) == 'linearcbond' then
            if contact.prop(cp, 'cb_state') == 3 then
              numBond = numBond + 1
            end_if
          end_if
        case 2 ; parallel-bonded material
          if contact.model(cp) == 'linearpbond' then
            if contact.prop(cp, 'pb_state') == 3 then
              numBond = numBond + 1
            end_if
          end_if
        case 3 ; soft-bonded material
          if contact.model(cp) == 'softbond' then
            if   (contact.prop(cp, 'sb_state') == 3) ...
               | (contact.prop(cp, 'sb_state') == 4) ...
               | (contact.prop(cp, 'sb_state') == 5) then
              numBond = numBond + 1
            end_if
          end_if
        case 4 ; flat-jointed material
          if contact.model(cp) == 'flatjoint' then
            local nE
            if global.dim == 3 then
              nE = contact.prop(cp, 'fj_nr') * contact.prop(cp, 'fj_nal')
            else ; 2D model
              nE = contact.prop(cp, 'fj_nr')
            end_if
            loop for ( local e = 1, e <= nE, e = e + 1 )
              contact.prop(cp, 'fj_elem') = e
              if contact.prop(cp, 'fj_state') == 3 then
                numBond = numBond + 1
              end_if
            end_loop
          end_if
      end_case
    end_loop
    ft_bNumBond = numBond
  else
    ft_bNumBond = 0
  end_if
end
;------------------------------------------------
fish define ft_clNumBond( cl )
; Return number of intact bonds of clump cl.
;
  if ft_mBonded then ; bonded material
    local numBond = 0
    loop foreach local cp clump.contactmap(cl)
      case_of cm_matType
        case 1 ; contact-bonded material
          if contact.model(cp) == 'linearcbond' then
            if contact.prop(cp, 'cb_state') == 3 then
              numBond = numBond + 1
            end_if
          end_if
        case 2 ; parallel-bonded material
          if contact.model(cp) == 'linearpbond' then
            if contact.prop(cp, 'pb_state') == 3 then
              numBond = numBond + 1
            end_if
          end_if
        case 3 ; soft-bonded material
          if contact.model(cp) == 'softbond' then
            if   (contact.prop(cp, 'sb_state') == 3) ...
               | (contact.prop(cp, 'sb_state') == 4) ...
               | (contact.prop(cp, 'sb_state') == 5) then
              numBond = numBond + 1
            end_if
          end_if
        case 4 ; flat-jointed material
          if contact.model(cp) == 'flatjoint' then
            local nE
            if global.dim == 3 then
              nE = contact.prop(cp, 'fj_nr') * contact.prop(cp, 'fj_nal')
            else ; 2D model
              nE = contact.prop(cp, 'fj_nr')
            end_if
            loop for ( local e = 1, e <= nE, e = e + 1 )
              contact.prop(cp, 'fj_elem') = e
              if contact.prop(cp, 'fj_state') == 3 then
                numBond = numBond + 1
              end_if
            end_loop
          end_if
      end_case
    end_loop
    ft_clNumBond = numBond
  else
    ft_clNumBond = 0
  end_if
end
;------------------------------------------------
fish define ft_cGrainGrain(cp)
  local cGrainGrain = false
  if      type.pointer.id(cp) == contact.typeid('ball-ball')     then
    cGrainGrain = true
  else if type.pointer.id(cp) == contact.typeid('ball-pebble')   then
    cGrainGrain = true
  else if type.pointer.id(cp) == contact.typeid('pebble-pebble') then
    cGrainGrain = true
  end_if
  ft_cGrainGrain = cGrainGrain
end
;------------------------------------------------
fish define ft_cGrainWall(cp)
  local cGrainWall = false
  if      type.pointer.id(cp) == contact.typeid('ball-facet')   then
    cGrainWall = true
  else if type.pointer.id(cp) == contact.typeid('pebble-facet') then
    cGrainWall = true
  end_if
  ft_cGrainWall = cGrainWall
end
;------------------------------------------------
fish define ft_cLinearBased( cp )
; Return true if cp is a linear-based contact.
;
  local bLinearBased = false
  if      contact.model(cp) == 'linear'      then
    bLinearBased = true
  else if contact.model(cp) == 'linearcbond' then
    bLinearBased = true
  else if contact.model(cp) == 'linearpbond' then
    bLinearBased = true
  end_if
  ft_cLinearBased = bLinearBased
end
;------------------------------------------------
fish define ft_cBondable( cp )
; Return true if cp is a bondable contact.
;
  if   (contact.model(cp) == 'linearcbond') ...
     | (contact.model(cp) == 'linearpbond') ...
     | (contact.model(cp) == 'softbond')    ...
     | (contact.model(cp) == 'flatjoint') then
    ft_cBondable = true
  else
    ft_cBondable = false
  end_if
end
;------------------------------------------------
fish define ft_cBondIt( cp )
; Invokes the bond method of the linear contact bond, linear parallel bond, soft bond
; or flat joint models such that the interface, second interface, interface or
; all elements (respectively) will become bonded.
;
  if ft_cBondable( cp ) then
    local gapInterval = vector( -1e20, 1e20 )
    local args = array.create(1,2)
          args(1,1) = 'gap'
          args(1,2) = gapInterval
    contact.method(cp, 'bond', args)
  end_if
end
;------------------------------------------------
fish define ft_cAssignLinProps( cp, emod, krat, fric )
  contact.prop(   cp, 'fric') = fric
  contact.inherit(cp, 'fric') = off
  contact.prop(cp, 'rgap'    ) = 0.0
  if contact.model(cp) == 'softbond' then
    contact.prop(cp, 'sb_mode') = 0
  else
    contact.prop(cp, 'lin_mode') = 0
  end_if
  local args = array.create(2,2)
        args(1,1) = 'emod'
        args(1,2) = emod
        args(2,1) = 'kratio'
        args(2,2) = krat
  contact.method(cp, 'deformability', args) ; sets {kn,ks} inherit=off
  contact.prop(cp, 'dp_nratio') = 0.0
  contact.prop(cp, 'dp_sratio') = 0.0
  contact.prop(cp, 'dp_mode'  ) = 0
end
;************************************************
; Bond coordination number measurement, public functions: bcn.
fish define bcnMeasure
; Measure the bond coordination number of grain sample. The bond coordination number is the
; average number of intact bonds per grain. The grain sample consists of grains (balls or clumps)
; with a 'bcnMark' property set to 'BCNsample'. Grains are marked via @bcnMark. The grains in the
; sample can be displayed with the ball and clump plot items by specifying: {ColorBy: Text Val:
; bcnMark}.
;
; OUT: bcn_numGrains - number of grains in the grain sample
;      mp_CNb        - bond coordination number of grain sample
;
  bcnMark
  ;
  bcn_numGrains = 0
  local nBonds = 0
  loop foreach local bp ball.list
    if ball.prop(bp, 'bcnMark') == 'BCNsample' then
      bcn_numGrains = bcn_numGrains + 1
      nBonds = nBonds + ft_bNumBond( bp )
    end_if
  end_loop
  loop foreach local cl clump.list
    loop foreach local pb clump.pebblelist(cl)
      if clump.pebble.prop(pb, 'bcnMark') == 'BCNsample' then
        bcn_numGrains = bcn_numGrains + 1
        nBonds = nBonds + ft_clNumBond( cl )
      end_if
      exit loop ; all pebbles of clump have been marked, we can just check one
    end_loop
  end_loop
  if bcn_numGrains # 0 then
    bcnMeasure = float(nBonds) / float(bcn_numGrains)
  end_if
end
;------------------------------------------------
fish define bcnMark
; Define the grain sample used by bcnMeasure. Redefine this function for user-defined marking.
;
; EFFECT: 'bcnMark' property of all grains is set to either 'BCNsample' or 'notBCNsample'
;
  loop foreach local bp ball.list
    ball.prop( bp, 'bcnMark' ) = 'notBCNsample'
    ; Place if-test here for user-defined marking
    if 1 == 1 then  ; Mark all balls
      ball.prop( bp, 'bcnMark' ) = 'BCNsample'
    end_if
  end_loop
  loop foreach local cl clump.list
    clump.prop( cl, 'bcnMark' ) = 'notBCNsample'
    ; Place if-test here for user-defined marking
    if 1 == 1 then  ; Mark all clumps
      clump.prop( cl, 'bcnMark' ) = 'BCNsample'
    end_if
  end_loop
end
;************************************************
; Grain size distribution measurement, public functions gsd_X, private functions _gsdX.
fish define gsdMeasure( numBins )
; Measure the grain size distribution (GSD) of grain sample. The grain sample consists of grains
; (balls or clumps) with the 'gsdMark' property set to 'GSDsample'. Grains are marked via @gsdMark.
; The grains in the sample can be displayed with the ball and clump plot items by specifying:
; {ColorBy: Text Val: gsdMark}.
;
; PARAMS:
;   numBins: number of bins in which to express the GSD (GSD table will have numBins+1 slots)
;              If all grains are same size, then setting numBins odd will make grain size fall
;              in middle of a bin; otherwise, grain size will fall on bin boundary.
;              It is more clear to have the grain size fall in middle of a bin.
;
; OUT: _gsdCalled    - gsdMeasure has been called (boolean)
;      gsd_numGrains - number of grains in the grain sample
;      GSD,
;      GSD-retained - name of tables in which GSD info. is stored
;                       x-value is {grain size (mm)} in range [dmin, dmax], where d{min,max} is
;                         {min, max} grain diameter of sampled grains; and
;                       y-value is
;                         GSD         : cumulative  mass percent passing  {mass passing (%)}
;                                       y-value in [0.0, 100.0]
;                         GSD-retained: incremental mass percent retained {mass (%)}
;                       The tables have numBins+1 slots s.t. mass passing is zero at grain size
;                       of dmin.
;
  if numBins < 2 then
    system.error = 'gsdMeasure: numBins must be greater than or equal to two.'
  end_if
  ;
  if _gsdCalled == false then ; first call to gsdMeasure
    local tp = table.create( 'GSD' )
          tp = table.create( 'GSD-retained' )
  else
    table.clear( 'GSD' )
    table.clear( 'GSD-retained' )
  end_if
  _gsdCalled = true
  loop local i (1, numBins+1)  ; Initialize tables with (0,0) in all slots.
    table.value( 'GSD'         , i ) = vector(0.0,0.0)
    table.value( 'GSD-retained', i ) = vector(0.0,0.0)
  end_loop
  ;
  gsdMark
  _gsdMakeGSDretained( numBins )
  _gsdMakeGSD
end
;------------------------------------------------
fish define gsdMark
; Define the grain sample used by gsdMeasure. Redefine this function for user-defined marking.
;
; EFFECT: 'gsdMark' property of all grains is set to either 'GSDsample' or 'notGSDsample'
;
  loop foreach local bp ball.list
    ball.prop( bp, 'gsdMark' ) = 'notGSDsample'
    ; Place if-test here for user-defined marking
    if 1 == 1 then  ; Mark all balls
      ball.prop( bp, 'gsdMark' ) = 'GSDsample'
    end_if
  end_loop
  loop foreach local cl clump.list
    clump.prop( cl, 'gsdMark' ) = 'notGSDsample'
    ; Place if-test here for user-defined marking
    if 1 == 1 then  ; Mark all clumps
      clump.prop( cl, 'gsdMark' ) = 'GSDsample'
    end_if
  end_loop
end
;------------------------------------------------
fish define gsdGetSizeOfPercentile( pct )
; Return grain size corresponding to percentile {pct}, for grain size distribution in GSD table.
; The returned value is linearly interpolated from the table values.
; PARAM:
;   pct : percentile in range [0.0, 100.0]
;
; IN: GSD table
;
  local numSlots = table.size( 'GSD' )
  if numSlots = 0 then
    system.error = 'gsdGetSizeOfPercentile: number of slots in table GSD is zero.'
  end_if
  if (pct < 0.0) | (pct > 100.0) then
    system.error = 'gsdGetSizeOfPercentile: parameter pct must be in range [0.0, 100.0].'
  end_if
  ;
  local x0, x1, y0, y1
  loop local i (2, numSlots)
    y1 = table.y( 'GSD', i )
    if y1 >= pct then
      x0 = table.x( 'GSD', i-1 )
      y0 = table.y( 'GSD', i-1 )
      x1 = table.x( 'GSD', i )
      exit loop
    end_if
  end_loop
  if math.abs( y1 - y0 ) >= _ftCheckZeroTol then
    gsdGetSizeOfPercentile = x0  +  ( (x1 - x0) / (y1 - y0) ) * (pct - y0)
  else
    gsdGetSizeOfPercentile = x0
  end_if
end
;------------------------------------------------
fish define _gsdMakeGSDretained( numBins )
; Make GSD-retained table.
;
; OUT: GSD-retained (table)
;      gsd_numGrains
;
  _gsdBounds ;{o: _gsdDmin, _gsdDmax}
  local eps
  if math.abs(_gsdDmax - _gsdDmin) > 1.0e-6 then
    eps = 0.01 * ( (_gsdDmax - _gsdDmin)/numBins )
  else
    eps = 0.01 * _gsdDmax
  end_if
  local DminMinus = _gsdDmin - eps
  local DmaxPlus  = _gsdDmax + eps
  local s         = DmaxPlus - DminMinus ; s > 0
  local deltaX = float(s / numBins)
  ;
  table.x( 'GSD-retained', 1 ) = DminMinus
  table.y( 'GSD-retained', 1 ) = 0.0
  loop local slt (2, numBins+1)
    table.x( 'GSD-retained', slt ) = table.x( 'GSD-retained', slt-1 ) + deltaX
    table.y( 'GSD-retained', slt ) = 0.0
  end_loop
  ;
  local cntG = 0
  local sumMass = 0.0
  loop foreach local bp ball.list
    if ball.prop(bp, 'gsdMark') == 'GSDsample' then
      cntG = cntG + 1
      local diam = 2.0 * ball.radius(bp)
      local mass = ball.mass.real(bp)
      local xi = (diam - DminMinus) / s  ; s > 0 because of its definition above
      slt = int( xi * numBins ) + 2
      table.y( 'GSD-retained', slt ) = table.y( 'GSD-retained', slt ) + mass
      sumMass = sumMass + mass
    end_if
  end_loop
  loop foreach local cl clump.list
    loop foreach local pb clump.pebblelist(cl)
      if clump.pebble.prop(pb, 'gsdMark') == 'GSDsample' then
        cntG = cntG + 1
        diam = _clDiam(cl)
        mass = clump.mass.real(cl)
        xi = (diam - DminMinus) / s  ; s > 0 because of its definition above
        slt = int( xi * numBins ) + 2
        table.y( 'GSD-retained', slt ) = table.y( 'GSD-retained', slt ) + mass
        sumMass = sumMass + mass
      end_if
      exit loop ; all pebbles of clump have been marked, we can just check one
    end_loop
  end_loop
  ; Normalize by total mass, to get mass percent.
  if sumMass < 1.0e-6 then
    system.error = '_gsdMakeGSDretained: sumMass is zero.'
  end_if
  loop slt (1, numBins+1)
    table.y( 'GSD-retained', slt ) = 100.0 * (table.y( 'GSD-retained', slt ) / sumMass)
  end_loop
  gsd_numGrains = cntG
end
;------------------------------------------------
fish define _gsdBounds  ;{o: _gsdDmin, _gsdDmax}
  local Dmin = 1.0e20
  local Dmax = 0.0
  loop foreach local bp ball.list
    if ball.prop(bp, 'gsdMark') == 'GSDsample' then
      local diam = 2.0 * ball.radius(bp)
      Dmin = math.min( Dmin, diam )
      Dmax = math.max( Dmax, diam )
    end_if
  end_loop
  loop foreach local cl clump.list
    loop foreach local pb clump.pebblelist(cl)
      if clump.pebble.prop(pb, 'gsdMark') == 'GSDsample' then
        diam = _clDiam(cl)
        Dmin = math.min( Dmin, diam )
        Dmax = math.max( Dmax, diam )
      end_if
      exit loop ; all pebbles of clump have been marked, we can just check one
    end_loop
  end_loop
  _gsdDmin = Dmin
  _gsdDmax = Dmax
end
;------------------------------------------------
fish define _gsdMakeGSD
; Make GSD table, assuming that GSD-retained table is valid.
;
; IN:  GSD-retained table
; OUT: GSD table
;
  local numSlots = table.size( 'GSD-retained' )
  loop local i (1, numSlots)
    table.x( 'GSD', i ) = table.x( 'GSD-retained', i )
    table.y( 'GSD', i ) = 0.0
  end_loop
  table.y( 'GSD', 1 ) = table.y( 'GSD-retained', 1 )
  loop i (2, numSlots)
    table.y( 'GSD', i ) = table.y( 'GSD', i-1 ) + table.y( 'GSD-retained', i )
  end_loop
end
;------------------------------------------------
fish define _clDiam( cl )
; Return clump diameter, volume-equivalent sphere (3D)/unit-thickness disk (2D)
  local diam
  if global.dim == 3 then
    diam = (6.0 * clump.vol(cl) / math.pi)^(1.0/3.0)
  else ; 2D model
    diam = math.sqrt(4.0 * clump.vol(cl) / math.pi)
  end_if
  _clDiam = diam
end
;************************************************
fish define mpMake( justGrains, msActivate )
; Make the material from a new model state. If justGrains = 1, then only make the grains
; and list their microstructural properties. This allows one to establish the relationship
; between diameter muliplier (cm_Dmult) and vessel resolution. After the desired resolution
; is obtained, then make the material by setting justGrains = 0.
; PARAM:
;  justGrains : {0, 1} = {Make the material & continue, Determine vessel resolution & stop}
;  msActivate : If true, then activate microstructural plotting (by calling msOn).
;               Boolean parameter that must be surrounded by square brackets when calling
;               mpMake --- for example, mpMake( 0, [true] ).
;
; IN:  {common, packing and material parameters}, msActivate
; OUT: Saved States (with corresponding model titles):
;        <cm_matNameSAV>-{matV : material in physical vessel
;                         mat  : material removed from physical vessel (if bonded material)
;                         perV : material in periodic vessel}
;        if periodic vessel, then
;          <cm_matNameSAV>.p2brk (material in form of a periodic brick)
;      mpGrp(i) : group name of grains in sizeDist-i, i=1,2,...,cm_nSD
;                   The names are <cm_matName>-SD<i>, e.g., Class5_dense-SD1.
;
  ft_SetTitle( 'Making ' + cm_matName + ' material...' )
  ;
  local myStr = '## mpMake, '
  if justGrains # 0 then
    myStr = myStr + 'Determining vessel resolution'
  else
    myStr = myStr + 'Making the material and continuing'
  end_if
  myStr = myStr + ' (entering).'
  io.out( myStr )
  if cm_matType == 5 then ; user-defined material
    if cm_modName # 'hill' then  ; hill model is built into PFC 6.0
      command
        program load contactmodelmechanical [cm_modName]
      end_command
    end_if
  end_if
  ;
  ; *** Make the grains, specify their density and local-damping factor.
  _mpMakeGrains( pk_seed, pk_nc )
  _mpSetGrainDensity
  _mpSetGrainDamp( cm_localDampFac )
  if justGrains # 0 then
    mpListMicroStrucProps
    system.error = 'Stopping as planned, microstructural properties have been listed above.'
  end_if
  gsdMeasure( 79 ) ; create GSD table for display
  ;
  ; *** Perform material genesis, then save model.
  _mpPackingPhase
  if _pkSavPreFinal # 0 then
    ft_SaveState( cm_matNameSAV, 'preFinal' )
  end_if
  _mpFinalizationPhase
  if msActivate then
    msOn
  end_if
  if mv_type == 0 then
    ft_SetTitle( cm_matName + ' material in physical vessel.' )
    ft_SaveState( cm_matNameSAV, 'matV' )
    ;
    ; *** If a bonded material, then
    ;     remove from physical vessel and allow to relax, and save model.
    if ft_mBonded then ; bonded material
      mv_wRemove
      ft_eq( pk_ARatLimit, pk_stepLimit )
      command
        history delete
      end_command
      ft_ZeroGrainDisplacement
      msForceUpdate
      ft_SetTitle( cm_matName + ' material removed from physical vessel.' )
      ft_SaveState( cm_matNameSAV, 'mat' )
    end_if
  else ; mv_type == 1
    if mv_Sinstall == 1 then
      mvInstallStress
    end_if
    local fName = string(cm_matNameSAV) + '.p' + string(global.dim) + 'brk'
    command
      brick make   id 1
      brick export id 1 filename [fName] skip-errors
    end_command
    ft_SetTitle( cm_matName + ' material in periodic vessel.' )
    ft_SaveState( cm_matNameSAV, 'perV' )
  end_if
  io.out('## mpMake (exiting).')
end
;************************************************
fish define mvInstallStress
; Install stress into bonded and stress free periodic assembly by deforming the periodic space.
; Gain is determined automatically (based on mv_Semod) s.t. during each step, each del_stress
; is reduced by one half.
;
; IN:  mv_S{x,y,z}, mv_Stol, mv_Semod, mv_SARatLimit, _mvSignore
;      mv_ms{xx,yy,zz}
; OUT: _mvSgainPer
;
  io.out('## mvInstallStress (entering).')
  ft_SetTitle( 'Installing stress into '+cm_matName+' material by deforming periodic space.' )
  ;
  _mvSnumBreak = 0
  local E0 = 2.0 * mv_Semod  ; Insure convergence condition stated above via Eqn. (3.38)
  local Ns = 1               ; in PFC 4.0 manual, 3.9 Stress-Installation Procedure
  _mvSgainPer = 1.0 / ( E0 * Ns * mech.timestep )
  command
    fish callback add @_mvSbondBreak event bond_break
    ;
    model domain tolerance 1e-2
    model solve fish-call -1.0 @_mvSupdateSR ...
                fish-halt @_mvShalt ...
                ratio-average @mv_SARatLimit ...
                cycles 100 ...
                and
  end_command
  domain.strain.rate(1,1) = 0.0
  domain.strain.rate(2,2) = 0.0
  if global.dim == 3 then
    domain.strain.rate(3,3) = 0.0
  end_if
  ;
  io.out('** '+string(_mvSnumBreak) + ' bond breaks occurred during stress installation.')
  if (_mvSignore == 0) & (_mvSnumBreak > 10) then
    local myStr = 'More than 10 bond breaks occurred during stress installation.'
          myStr = myStr + ' To ignore, set _mvSignore = 1 and rerun.'
    system.error = myStr
  end_if
  command
    fish callback remove @_mvSBondBreak event bond_break
  end_command
  io.out('## mvInstallStress (exiting).')
end
;------------------------------------------------
fish define _mvSupdateSR
;  Update strain rate of periodic space, based on deviations from target stress.
;
; IN: mv_S{x,y,z}, mv_ms{xx,yy,zz}, _mvSgainPer
;
  domain.strain.rate(1,1) = (mv_Sx - mv_msxx) * _mvSgainPer
  domain.strain.rate(2,2) = (mv_Sy - mv_msyy) * _mvSgainPer
  if global.dim == 3 then
    domain.strain.rate(3,3) = (mv_Sz - mv_mszz) * _mvSgainPer
  end_if
end
;------------------------------------------------
fish define _mvShalt ;{i: mv_Stol, mv_S{x,y,z}, mv_ms{xx,yy,zz}}
  _mvShalt = false
  local ratioMax = math.max( math.abs( (mv_msxx - mv_Sx) / mv_Sx ), ...
                             math.abs( (mv_msyy - mv_Sy) / mv_Sy )      )
  if global.dim == 3 then
    ratioMax = math.max( ratioMax, math.abs( (mv_mszz - mv_Sz) / mv_Sz ) )
  end_if
  if ratioMax <= mv_Stol then
    _mvShalt = true
  end_if
end
;------------------------------------------------
fish define _mvSbondBreak( args )
  _mvSnumBreak = _mvSnumBreak + 1
end
;************************************************
fish define mpMakeFromBrick( ctr )
; Make the material from a periodic brick. The specimen is centered at the given center.
; The domain is non-periodic and larger than the specimen.
; PARAMS:
;   ctr : location of specimen center (wrt global coordinate system) [vector]
;
; IN:  material parameters (used by ft_setMatBehavior)
;      <cm_matNameSAV>.p{2,3}brk
;      mv_perN{x,y,z}, mv_{H,W,D}, fjm_trackMS
; OUT: mp_FromBrick ({0/1} = {not created/created} from a periodic brick}
;      Saved State (with corresponding model title):
;         <cm_matNameSAV>-matB : material assembled from periodic brick
;
  ft_SetTitle( 'Making ' + cm_matName + ' material from periodic brick...' )
  ;
  local fName = string(cm_matNameSAV) + '.p' + string(global.dim) + 'brk'
  local lenX, lenY, lenZ
  if global.dim == 3 then
    lenX = mv_D * mv_perNx
    lenY = mv_W * mv_perNy
    lenZ = mv_H * mv_perNz
    command
      model domain extent [ctr->x - lenX] [ctr->x + lenX] ...
                          [ctr->y - lenY] [ctr->y + lenY] ...
                          [ctr->z - lenZ] [ctr->z + lenZ] ...
                   condition stop stop stop
      brick import   id 5 filename [fName]
      brick assemble id 5 origin [ctr->x - 0.5*lenX] [ctr->y - 0.5*lenY] [ctr->z - 0.5*lenZ] ...
                            size [mv_perNx] [mv_perNy] [mv_perNz]
    end_command
  else  ; 2D model
    lenX = mv_W * mv_perNx
    lenY = mv_H * mv_perNy
    command
      model domain extent [ctr->x - lenX] [ctr->x + lenX] ...
                          [ctr->y - lenY] [ctr->y + lenY] ...
                   condition stop stop
      brick import   id 5 filename [fName]
      brick assemble id 5 origin [ctr->x - 0.5*lenX] [ctr->y - 0.5*lenY] ...
                          size [mv_perNx] [mv_perNy]
    end_command
  end_if
  local noFric = -99.0
  ft_setMatBehavior( 'future', 0.0, noFric )  ; specify behavior of future contacts
  if (cm_matType == 4) & (fjm_trackMS == true) then
    msFG_Track
  end_if
  mp_FromBrick = 1
  ;
  ft_SetTitle( cm_matName + ' material assembled from periodic brick.' )
  ft_SaveState( cm_matNameSAV, 'matB' )
end
;------------------------------------------------
fish define _mpSetEffLinBehavior( cSet, prox, emod, krat, fric, cType, cmName )
; Set material behavior for existing and future contacts to be that of a linear-based material.
; PARAMS:
;   {cSet, prox} : see virtual function ft_setMatBehavior
;   emod   : effective modulus [float]
;   krat   : stiffness ratio [float]
;   fric   : friction coefficient [float]
;   cType  : contact type ('grain-grain', 'grain-wall') [string]
;   cmName : contact model name ('linear', 'linearcbond', 'linearpbond') [string]
;
  if      cSet == 'existing' then
  else if cSet == 'future'   then
  else
    system.error = '_mpSetEffLinBehavior cannot handle specified value for parameter cSet.'
  end_if
  if      cType == 'grain-wall'  then
  else if cType == 'grain-grain' then
  else
    system.error = '_mpSetEffLinBehavior cannot handle specified value for parameter cType.'
  end_if
  if      cmName == 'linear'      then
  else if cmName == 'linearcbond' then
  else if cmName == 'linearpbond' then
  else
    system.error = '_mpSetEffLinBehavior cannot handle specified value for parameter cmName.'
  end_if
  ;
  local myTypeStr = array.create(3)
  local tidx, tidxMax
  if cType == 'grain-grain' then
    myTypeStr(1) = 'ball-ball'
    myTypeStr(2) = 'ball-pebble'
    myTypeStr(3) = 'pebble-pebble'
    tidxMax = 3
  else ; cType == 'grain-wall'
    myTypeStr(1) = 'ball-facet'
    myTypeStr(2) = 'pebble-facet'
    tidxMax = 2
  end_if
  if cSet == 'existing' then
    loop for ( tidx = 1, tidx <= tidxMax, tidx = tidx + 1 )
      command
        contact method deformability emod [emod] krat [krat]             range contact type [myTypeStr(tidx)]
        contact property fric [fric] inheritance off ...
                         rgap 0.0 lin_mode 0 dp_nratio 0.0 dp_sratio 0.0 range contact type [myTypeStr(tidx)]
      end_command
    end_loop
  else ; cSet = 'future'
    loop for ( tidx = 1, tidx <= tidxMax, tidx = tidx + 1 )
      command
        contact cmat default type [myTypeStr(tidx)] ...
                     model [cmName] ...
                     method deformability emod [emod] krat [krat] ...
                     property fric [fric] inheritance off rgap 0.0 lin_mode 0 dp_nratio 0.0 dp_sratio 0.0
        contact cmat proximity [prox]
      end_command
    end_loop
    command
      model clean ; Create contacts between all grains within [prox] of one another.
    end_command
  end_if
end
;------------------------------------------------
fish define _mpPackingPhase
; Perform material-genesis packing phase.
;
; IN: packing parameters
;
; The first step of the packing phase has been performed by _mpMakeGrains.
  _mpPackIsoState
  if pk_procCode == 0 then ; boundary contraction
    _mpPackBdryContract
  else ; grain scaling
    _mpPackGrainScale
  end_if
end
;------------------------------------------------
fish define _mpPackIsoState
; Enforce linear behavior (with given effective modulus and friction coefficient of zero), and
; then allow the grains to rearrange until either the mean stress is near zero (within 0.1% of pk_Pm) or
; static equilibrium is obtained.
;
; IN: pk_Pm, mv_wsm
;     pk_ARatLimit, pk_stepLimit,
;
  io.out('## _mpPackIsoState (entering).')
  local noProx = -99.0
  ft_setMatBehavior( 'existing', noProx, 0.0 )
  ft_setMatBehavior(   'future',    0.0, 0.0 )
  ;
  local myStr = '   Perform calming (via model cycle calm 5) until max overlap-ratio'
        myStr = myStr + ' is less than or equal to '+string(_pkORmaxLimit)
  io.out( myStr )
  _pkORcnt = _pkORupdateRate ; force an update during first cycle
  command
    model solve calm 5 fish-halt @_mpMaxORisSmall
  end_command
  io.out('   **Calming done, max overlap-ratio: '+string(mp_ORmax))
  _mpDeleteGrainsOutOfVessel
  ;
  io.out('   Cycle until mean stress is near zero or static equilibrium is obtained.')
  command
    model solve fish-halt @_mpMSisNearZero ratio-average [pk_ARatLimit] cycles [pk_stepLimit]
  end_command
  _mpDeleteGrainsOutOfVessel
  if _mpMSisNearZero == 1 then
    io.out('   **Mean stress is near zero.')
  else
    io.out('   **Static equilibrium obtained within desired tolerance.')
  end_if
  io.out('## _mpPackIsoState (exiting).')
end
;------------------------------------------------
fish define _mpMaxORisSmall  ;{i: _pkORmaxLimit, _pkORcnt, _pkORupdateRate}
  _mpMaxORisSmall = 0
  _pkORcnt = _pkORcnt + 1
  if _pkORcnt >= _pkORupdateRate then
    if global.cycle > 1000 then
      _mpDeleteGrainsOutOfVessel
    end_if
    ft_OverlapRatios
    io.out('     max overlap-ratio: '+string(mp_ORmax))
    if mp_ORmax <= _pkORmaxLimit then
      _mpMaxORisSmall = 1
    end_if
    _pkORcnt = 0
  end_if
end
;------------------------------------------------
fish define _mpMSisNearZero
  local meanStress
  if mv_type == 0 then
    meanStress = mv_wsm
  else ; mv_type == 1
    meanStress = mv_msm
  end_if
  if meanStress >= -1e-3*pk_Pm then  ; Mean stress will be negative until the assembly unloads.
                                     ; Unloaded if mean stress is 0.1% of pk_Pm.
    _mpMSisNearZero = 1
  else
    _mpMSisNearZero = 0
  end_if
end
;------------------------------------------------
fish define _mpDeleteGrainsOutOfVessel
; For a clumped material, delete protruding pebbles.
  if mv_type == 1 then
    exit  ; periodic vessel has no outside
  end_if
  ;
  local numGrains0 = ball.num + clump.num
  if mv_shape == 0 then
    if global.dim == 3 then
      if cm_shape == 0 then
        command
          ball delete range position-x [-0.5*mv_D] [0.5*mv_D] not
          ball delete range position-y [-0.5*mv_W] [0.5*mv_W] not
          ball delete range position-z [-0.5*mv_H] [0.5*mv_H] not
        end_command
      else ; cm_shape == 1
        command
          clump delete pebbles range position-x [-0.5*mv_D] [0.5*mv_D] not
          clump delete pebbles range position-y [-0.5*mv_W] [0.5*mv_W] not
          clump delete pebbles range position-z [-0.5*mv_H] [0.5*mv_H] not
        end_command
    end_if
    else ; 2D model
      if cm_shape == 0 then
        command
          ball delete range position-x [-0.5*mv_W] [0.5*mv_W] not
          ball delete range position-y [-0.5*mv_H] [0.5*mv_H] not
        end_command
      else ; cm_shape == 1
        command
          clump delete pebbles range position-x [-0.5*mv_W] [0.5*mv_W] not
          clump delete pebbles range position-y [-0.5*mv_H] [0.5*mv_H] not
        end_command
      end_if
    end_if
  else if mv_shape == 1
    if cm_shape == 0 then
      command
        ball delete range cylinder end-1 (0.0, 0.0, [-0.5*mv_H]) ...
                                   end-2 (0.0, 0.0, [ 0.5*mv_H]) ...
                                   radius [0.5*mv_W]             ...
                                   not
      end_command
    else ; cm_shape == 1
      command
        clump delete pebbles range cylinder end-1 (0.0, 0.0, [-0.5*mv_H]) ...
                                            end-2 (0.0, 0.0, [ 0.5*mv_H]) ...
                                            radius [0.5*mv_W]             ...
                                            not
      end_command
    end_if
  else ; mv_shape == 2
    if cm_shape == 0 then
      command
        ball delete range sphere center (0.0, 0.0, 0.0) ...
                                 radius [0.5*mv_H]      ...
                                 not
      end_command
    else ; cm_shape == 1
      command
        clump delete pebbles range sphere center (0.0, 0.0, 0.0) ...
                                          radius [0.5*mv_H]      ...
                                          not
      end_command
    end_if
  end_if
  local numGrains1 = ball.num + clump.num
  local numDel = numGrains0 - numGrains1
  if numDel > 0 then
    io.out('   **Deleted ' + string(numDel) + ' grains with centers outside of material vessel.')
  end_if
end
;------------------------------------------------
fish define _mpPackBdryContract
; Enforce linear behavior (with given parameters), and then apply confinement of pk_Pm.
; Confinement is applied via the servomechanism until the wall pressures are within
; pk_PTol of pk_Pm. De-activate the servomechanism (insuring that all wall velocities
; are zero).
;
  io.out('## _mpPackBdryContract (entering).')
  local noProx = -99.0
  ft_setMatBehavior( 'existing', noProx, pk_fricCA )
  ft_setMatBehavior(   'future',    0.0, pk_fricCA )
  ;
  mvs_vLimit = pk_vLimit
  mvs_on
  mv_mStrainZero
  mv_wStrainZero
  mvs_applyConfinement( pk_Pm, pk_PTol, pk_ARatLimit, pk_stepLimit )
  mvs_off
  io.out('## _mpPackBdryContract (exiting).')
end
;------------------------------------------------
fish define _mpPackGrainScale
; Scale the grain size iteratively to modify the mean stress of the assembly until the
; mean stress is within pk_PTol of pk_Pm.
;
; IN: pk_Pm, pk_PTol, pk_ARatLimit, pk_stepLimit
;
  io.out('## _mpPackGrainScale (entering).')
  ;
  if _mpMSisNearZero == 1 then
    system.error = 'Mean stress is near zero, grain-scaling proc. must begin with a tight pack.'
  end_if
  ;
  _GSiterN = 0
  _GSaccumSFac = 1.0
  loop while _GSPMet( pk_Pm, pk_PTol ) # 1
    _GSapplyAlpha( _GSgetAlpha ) ;{o: _GSiterN, _GSaccumSFac}
    io.out('   Cycle until mean stress is near zero or static equilibrium is obtained.')
    command
      model cycle 10 ; propagate effect of radius change
      model solve fish-halt @_mpMSisNearZero ratio-average [pk_ARatLimit] cycles [pk_stepLimit]
    end_command
    if _mpMSisNearZero == 1 then
      system.error = 'Mean stress is now near zero, this situation is not yet handled [try to reduce pk_ARatLimit].'
    else
      io.out('   **Static equilibrium obtained within desired tolerance.')
    end_if
  end_loop
  ;
  io.out('## _mpPackGrainScale (exiting).')
end
;------------------------------------------------
fish define _GSPMet( Pm, PTol )
; Returns 1 iff current material pressure (-mv_wsm or -mv_msm) is within pressure tolerance [PTol] of [Pm].
  local P
  if mv_type == 0 then
    P = -mv_wsm
  else
    P = -mv_msm
  end_if
  local epsP = math.abs( P - Pm ) / Pm
  io.out('   Target  material pressure: '+string(Pm))
  io.out('   Current material pressure: '+string(P))
  io.out('   Target  pressure tolerance: '+string(PTol))
  io.out('   Current pressure tolerance: '+string(epsP))
  if epsP <= PTol then
    _GSPMet = 1
    io.out('   **Target pressure achieved within desired tolerance.')
  else
    _GSPMet = 0
  end_if
end
;------------------------------------------------
fish define ft_cPosPeriodic( cp, bp )
; Return position of contact (cp) wrt ball (bp) when periodic space is active.
; This will also work for normal space. The ball is a non-ghost ball, and the contact
; may be with the ghost ball (and thus, on the opposite side of the periodic domain).
;
  if mv_type == 0 then
    ft_cPosPeriodic = contact.pos(cp)
  else ; mv_type == 1
    if contact.end1(cp) == bp then
      ft_cPosPeriodic = contact.pos(cp)
    else
      ft_cPosPeriodic = contact.pos(cp) - contact.offset(cp)
    end_if
  end_if
end
;------------------------------------------------
fish define _GSgetAlpha
  local cp
  local _denom = 0.0
  loop foreach local bp ball.list ; all balls in model
    loop foreach cp ball.contactmap(bp) ; all active contacts of ball bp
      local Kn  = contact.prop(cp, 'kn')
      local cPos = ft_cPosPeriodic( cp, bp )
      local Rcp = math.mag( cPos - ball.pos(bp) )
      local Rpo = _GSgetRpoBP( bp, cp )
      local Phi = ball.radius(bp) + Rpo
      _denom = _denom + (Rcp * Kn * Phi)
    end_loop
  end_loop
  ;
  loop foreach local cl clump.list ; all clumps in model
  ; This section will not work for periodic vessel, must use offset for positions.
    loop foreach cp clump.contactmap(cl) ; all active contacts of clump cl
             Kn = contact.prop(cp, 'kn')
      local Rcl = math.mag(  contact.pos(cp) - clump.pos(cl) )
      local nk  = math.unit( contact.pos(cp) - clump.pos(cl) )
      local pb  = _GSgetPebble( cl, cp )
            Rpo = _GSgetRpo(    cl, cp )
            Phi = clump.pebble.radius(pb) + Rpo
      local mk  = math.unit( contact.pos(cp) - clump.pebble.pos(pb) )
      _denom = _denom + (Rcl * Kn * Phi * math.dot(nk, mk))
    end_loop
  end_loop
  ;
  local delMS
  if mv_type == 0 then
    delMS = -pk_Pm - mv_wsm
  else ; mv_type == 1
    delMS = -pk_Pm - mv_msm
  end_if
  if _denom == 0.0 then
    _GSgetAlpha = 0.0
  else
    _GSgetAlpha = -float(global.dim) * _mvVolume(true) * delMS / _denom
  end_if
end
;------------------------------------------------
fish define _GSgetPebble( cl, cp )
; Return the pebble of clump cl that is at the contact cp
; PARAMS: cl - clump
;         cp - active contact of clump cl
;
  if      type.pointer.id(cp) == contact.typeid('ball-pebble') then
    _GSgetPebble = contact.end2(cp)
  else if type.pointer.id(cp) == contact.typeid('pebble-pebble') then
    if clump.pebble.clump( contact.end1(cp) ) == cl then
      _GSgetPebble = contact.end1(cp)
    else
      _GSgetPebble = contact.end2(cp)
    end_if
  else ; pebble-facet contact
    _GSgetPebble = contact.end1(cp)
  end_if
end
;------------------------------------------------
fish define _GSgetRpo( cl, cp )
; Return the radius of the other object (ball, pebble or facet) that is at the contact cp.
; PARAMS: cl - clump
;         cp - active contact of clump cl
;
  if      type.pointer.id(cp) == contact.typeid('ball-pebble') then
    _GSgetRpo = ball.radius( contact.end1(cp) )
  else if type.pointer.id(cp) == contact.typeid('pebble-pebble') then
    if clump.pebble.clump( contact.end1(cp) ) == cl then
      _GSgetRpo = clump.pebble.radius( contact.end2(cp) )
    else
      _GSgetRpo = clump.pebble.radius( contact.end1(cp) )
    end_if
  else ; pebble-facet contact
    _GSgetRpo = 0.0
  end_if
end
;------------------------------------------------
fish define _GSgetRpoBP( bp, cp )
; Return the radius of the other object (ball, pebble or facet) that is at the contact cp.
; PARAMS: bp - ball
;         cp - active contact of ball bp
;
  if      type.pointer.id(cp) == contact.typeid('ball-pebble') then
    _GSgetRpoBP = clump.pebble.radius( contact.end2(cp) )
  else if type.pointer.id(cp) == contact.typeid('ball-ball') then
    if contact.end1(cp) == bp then
      _GSgetRpoBP = ball.radius( contact.end2(cp) )
    else
      _GSgetRpoBP = ball.radius( contact.end1(cp) )
    end_if
  else ; ball-facet contact
    _GSgetRpoBP = 0.0
  end_if
end
;------------------------------------------------
fish define _GSapplyAlpha( alpha ) ;{o: _GSiterN, _GSaccumSFac}
  _GSiterN = _GSiterN + 1
  local sFac = 1.0 + alpha
  _GSaccumSFac = _GSaccumSFac * sFac
  ;
  io.out('     Iteration: '+string(_GSiterN))
  io.out('     Scaling grains by factor: '+string(sFac))
  io.out('           Accumulated factor: '+string(_GSaccumSFac))
  ;
  loop foreach local bp ball.list
    ball.radius(bp) = sFac * ball.radius(bp)
  end_loop
  loop foreach local cl clump.list
    local diam = _clDiam(cl)
    diam = sFac * diam  ; scaling diameter is same as scaling radius
    clump.scalesphere( cl, diam )
  end_loop
end
;------------------------------------------------
fish define _mpFinalizationPhase
; Perform material-genesis finalization phase.
;
; IN: cm_matType, material parameters
;
  ; Assign final material properties to existing grain-grain contacts, and
  ; specify material properties for future grain-grain contacts.
  ; For the bonded materials,
  ;   (1) Create contacts between all grains within the installation-gap distance of one another,
  ;   (2) assign final material properties to all contacts.
  ; We then return proximity to zero for all future contacts.
  local noProx = -99.0
  local noFric = -99.0
  case_of cm_matType
    case 0 ; linear material
      ft_setMatBehavior( 'existing',   noProx, noFric )
    case 1 ; contact-bonded material
      ft_setMatBehavior(   'future', cbm_igap, noFric )
      _mpAssignCB
    case 2 ; parallel-bonded material
      ft_setMatBehavior(   'future', pbm_igap, noFric )
      _mpAssignPB
    case 3 ; soft-bonded material
      ft_setMatBehavior(   'future', sbm_igap, noFric )
      _mpAssignSB
    case 4 ; flat-jointed material
      ft_setMatBehavior(   'future', fjm_igap, noFric )
      _mpAssignFJ
    case 5 ; user-defined material
      ft_setMatBehavior( 'existing',   noProx, noFric )
  end_case
  ft_setMatBehavior( 'future', 0.0, noFric )
  ;
  ; Remove resultant force/moment in grains from previous cycle, and set grain velocities to zero.
  if global.dim == 3 then
    if cm_shape == 0 then
      command
        ball attribute force-contact (0.0,0.0,0.0)  moment-contact (0.0,0.0,0.0)
        ball attribute velocity      (0.0,0.0,0.0)  spin           (0.0,0.0,0.0)
        ball attribute displacement  (0.0,0.0,0.0)
      end_command
    else ; cm_shape == 1
      command
        clump attribute force-contact (0.0,0.0,0.0)  moment-contact (0.0,0.0,0.0)
        clump attribute velocity      (0.0,0.0,0.0)  spin           (0.0,0.0,0.0)
        clump attribute displacement  (0.0,0.0,0.0)
      end_command
    end_if
  else ; 2D  model
    if cm_shape == 0 then
      command
        ball attribute force-contact (0.0,0.0)  moment-contact 0.0
        ball attribute velocity      (0.0,0.0)  spin          0.0
        ball attribute displacement  (0.0,0.0)
      end_command
    else ; cm_shape == 1
      command
        clump attribute force-contact (0.0,0.0)  moment-contact 0.0
        clump attribute velocity      (0.0,0.0)  spin          0.0
        clump attribute displacement  (0.0,0.0)
      end_command
    end_if
  end_if
  if ft_mBonded then ; bonded material
    ft_SmoothGrainWallInterface
  end_if
  ft_eq( pk_ARatLimit, pk_stepLimit ) ; Bring system back to equilibrium.
end
;------------------------------------------------
fish define _mpAssignSB
; Install soft-bond contact model and assign soft-bonded material properties
; to all grain-grain contacts, but only bond the contacts with a gap less
; than or equal to sbm_igap. The reference gap for the soft-bond contact
; model is zero unless a bond is installed. If a bond is installed and
; the contact gap is negative, then the reference gap is set equal to
; the contact gap at the time of bond installation.
;
; IN: soft-bonded material parameters
;
  loop foreach local cp contact.list.all
    if ft_cGrainGrain(cp) then
      contact.model(cp) = 'softbond'
      ft_cAssignLinProps( cp, sbm_emod, sbm_krat, sbm_fric )
      _mpAssignSBprops(cp)
      if contact.gap(cp) <= sbm_igap then
        _mpAssignSBbond( cp )
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _mpAssignPB
; Assign parallel-bonded material properties (linear and parallel-bond groups) to all grain-grain contacts,
; but only bond the contacts with a gap less than or equal to pbm_igap.
; The reference gap for the linear component of the linear parallel bond contact model
; is zero unless a bond is installed. If a bond is installed and the contact gap is negative, then
; the reference gap is set equal to the contact gap at the time of bond installation.
;
; IN: parallel-bonded material parameters
;
  loop foreach local cp contact.list.all
    if ft_cGrainGrain(cp) then
      ft_cAssignLinProps( cp, pbm_emod, pbm_krat, pbm_fric )
      _mpAssignPBprops(cp)
      if contact.gap(cp) <= pbm_igap then
        _mpAssignPBbond( cp )
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _mpAssignCB
; Assign contact-bonded material properties (linear and contact-bond groups) to all grain-grain contacts,
; but only bond the contacts with a gap less than or equal to cbm_igap.
; The reference gap is zero unless a bond is installed. If a bond is installed, then the reference gap
; is set equal to the contact gap at the time of bond installation.
;
; IN: contact-bonded material parameters
;
  loop foreach local cp contact.list.all
    if ft_cGrainGrain(cp) then
      ft_cAssignLinProps( cp, cbm_emod, cbm_krat, cbm_fric )
      if contact.gap(cp) <= cbm_igap then
        _mpAssignCBbond( cp )
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _mpAssignFJ
; Install flat-joint contact model at all grain-grain contacts with a gap less than or equal to fjm_igap,
; and assign flat-jointed material properties to these flat-jointed contacts.
; The remaining grain-grain contacts already possess the linear contact model and are assigned
; properties derived from the linear material group of the flat-jointed material properties.
;
; IN: flat-jointed material parameters
;
  loop foreach local cp contact.list.all
    if ft_cGrainGrain(cp) then
      if contact.gap(cp) <= fjm_igap then
        contact.model(cp) = 'flatjoint'
        _mpAssignFJprops(cp)
      else
        ft_cAssignLinProps( cp, lnm_emod, lnm_krat, lnm_fric )
      end_if
    end_if
  end_loop
  if (fjm_rmulCode == 1) | (fjm_rmulCode == 2) then
    _mpFJrmulReduce
  end_if
  _mpFJsetMicroStruc
  if fjm_trackMS == true then
    msFG_Track
  end_if
end
;------------------------------------------------
fish define _mpAssignFJProps( cp )  ; cp is a flat-jointed contact
  if contact.model(cp) # 'flatjoint' then
    system.error = '_mpAssignFJProps operating on a non flat-jointed contact.'
  end_if
  ;
  contact.prop( cp, 'fj_nr'   ) = fjm_Nr
  if global.dim == 3 then
    contact.prop( cp, 'fj_nal'  ) = fjm_Nal
  end_if
  contact.prop( cp, 'fj_rmul' ) = fjm_rmulVal
  contact.prop( cp, 'fj_fric' ) = fjm_fric
  contact.prop( cp, 'fj_ten'  ) = ft_valNormDist( fjm_ten_m, fjm_ten_sd )
  contact.prop( cp, 'fj_coh'  ) = ft_valNormDist( fjm_coh_m, fjm_coh_sd )
  contact.prop( cp, 'fj_fa'   ) = fjm_fa
  local args = array.create(2,2)
        args(1,1) = 'emod'
        args(1,2) = fjm_emod
        args(2,1) = 'krat'
        args(2,2) = fjm_krat
  contact.method(cp, 'deformability', args)
end
;------------------------------------------------
fish define _mpFJrmulReduce
; Perform radius-reduction algorithm on all flat-jointed contacts to obtain a valid microstructure.
; Visit each ball in the model. For each ball, visit all of its flat-jointed contacts. For each
; FJ contact, compare it with remaining FJ contacts to determine if the FJ faces overlap. If they
; overlap, then uniformly reduce their radii until they no longer overlap.
;
; NOTE: Does not work for clumped grains.
;
  io.out('## _mpFJrmulReduce (entering).')
  local maxContacts = 30
  local cList = array.create(maxContacts)
  loop for (local idx = 1, idx <= maxContacts, idx = idx + 1)
    cList(idx) = null
  end_loop
  loop foreach local bp ball.list
    local cNum = 0
    loop foreach local cp ball.contactmap.all(bp)
      if contact.model(cp) == 'flatjoint' then   ; FJ contacts of ball bp
        cNum = cNum + 1
        if cNum > maxContacts then
          system.error = '_mpFJrmulReduce: too many contacts around a ball.'
        end_if
        cList(cNum) = cp
      end_if
    end_loop
    ;
    loop for (local c1 = 1, c1 <= cNum, c1 = c1 + 1)
      loop for (local c2 = c1+1, c2 <= cNum, c2 = c2 + 1)
        _mpFJrmulRemoveOverlap( bp, cList(c1), cList(c2) )
      end_loop
    end_loop
  end_loop
  array.delete(cList)
  io.out('## _mpFJrmulReduce (exiting).')
end
;------------------------------------------------
fish define _mpFJrmulRemoveOverlap( bPtr, cpFJ1, cpFJ2 )
; Insure that the two FJ faces of the given ball do not overlap. If they overlap,
; then reduce the FJ radii until they no longer overlap.
;
; PARAMS:
;   bPtr  - given ball
;   cpFJ1 - FJ contact 1
;   cpFJ2 - FJ contact 2
;
  if contact.model(cpFJ1) # 'flatjoint' | contact.model(cpFJ2) # 'flatjoint' then
    system.error = '_mpFJrmulRemoveOverlap operating on a non flat-jointed contact.'
  end_if
  ;
  local cVec1 = ( ft_cPosPeriodic(cpFJ1, bPtr) ) - ball.pos(bPtr)
  local cVec2 = ( ft_cPosPeriodic(cpFJ2, bPtr) ) - ball.pos(bPtr)
  local lf1 = math.mag( cVec1 ) - 0.5*contact.prop(cpFJ1, 'fj_gap0')
  local lf2 = math.mag( cVec2 ) - 0.5*contact.prop(cpFJ2, 'fj_gap0')
  local beta = _ftAngMin( cVec1, cVec2, global.dim )
  ;
  local Rf1, Rf2, alpha1, alpha2
  loop while 1 # 0 ; infinite loop
    Rf1 = contact.prop(cpFJ1, 'fj_radius')
    Rf2 = contact.prop(cpFJ2, 'fj_radius')
    alpha1 = math.atan2( Rf1, lf1 )
    alpha2 = math.atan2( Rf2, lf2 )
    ;
    if (alpha1 + alpha2 - beta) > 0.0 then  ; overlap is true
      if fjm_rmulCode == 1 then
        ; Reduce both FJ radii by a small factor (one percent).
        contact.prop( cpFJ1, 'fj_rmul' ) = 0.99 * contact.prop( cpFJ1, 'fj_rmul' )
        contact.prop( cpFJ2, 'fj_rmul' ) = 0.99 * contact.prop( cpFJ2, 'fj_rmul' )
      else ; fjm_rmulCode == 2
        _mpFJrmulReduceAll
      end_if
    else ; overlap is false
      exit loop
    end_if
  end_loop
end
;------------------------------------------------
fish define _mpFJrmulReduceAll
; Reduce fjm_rmulVal by small amount, apply it to all FJs.
; IN/OUT: fjm_rmulVal
;
  fjm_rmulVal = 0.99 * fjm_rmulVal
  loop foreach local cp contact.list.all
    if contact.model(cp) == 'flatjoint' then
      contact.prop( cp, 'fj_rmul' ) = fjm_rmulVal
    end_if
  end_loop
end
;------------------------------------------------
fish define _mpFJsetMicroStruc
; Create the flat-jointed microstructure such that each flat joint is either
;   bonded (g_o = 0, bonded), gapped (g_o > 0, unbonded) or slit (g_o = 0, unbonded).
;
; IN: fjm_B_frac, fjm_G_frac, fjm_G_{m,sd}
;
  local nFJ = 0
    loop foreach local cp contact.list.all
      if contact.model(cp) == 'flatjoint' then
        nFJ = nFJ + 1
      end_if
    end_loop
  local nB  = math.round( fjm_B_frac * nFJ )
  local nG  = math.round( fjm_G_frac * nFJ )
  local nS  = nFJ - nB - nG
  local nC = 0
  loop foreach cp contact.list.all
    if contact.model(cp) == 'flatjoint' then
      nC = nC + 1
      if nC <= nB then           ; *** make bonded
        local makeB = makeB + 1
        contact.prop(   cp, 'fj_gap0' ) = 0.0
        ft_cBondIt(     cp )
      else if nC <= (nB+nG) then ; *** make gapped
        local makeG = makeG + 1
        contact.prop(   cp, 'fj_gap0' ) = ft_valNormDist( fjm_G_m, fjm_G_sd )
      else                       ; *** make slit
        local makeS = makeS + 1
        contact.prop(   cp, 'fj_gap0' ) = 0.0
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define _mpAssignSBprops( cp )
  ; Soft-bond group:
  contact.prop(cp, 'sb_rmul') = sbm_rmul
  contact.prop(cp, 'sb_mcf')  = sbm_mcf
  contact.prop(cp, 'sb_ten')  = ft_valNormDist( sbm_ten_m, sbm_ten_sd )
  contact.prop(cp, 'sb_coh')  = ft_valNormDist( sbm_coh_m, sbm_coh_sd )
  contact.prop(cp, 'sb_fa' )  = sbm_fa
  contact.prop(cp, 'sb_soft') = sbm_soft
  contact.prop(cp, 'sb_cut')  = sbm_cut
  contact.prop(cp, 'sb_bmul') = sbm_bmul
  contact.prop(cp, 'sb_tmul') = sbm_tmul
end
;------------------------------------------------
fish define _mpAssignSBbond( cp )
  ft_cBondIt( cp )
  if contact.gap(cp) < 0.0 then  ; remove overlap only, do not extend surfaces
    contact.prop(cp, 'rgap') = contact.gap(cp)
  end_if
end
;------------------------------------------------
fish define _mpAssignPBprops( cp )
  ; Parallel-bond group:
  contact.prop(cp, 'pb_rmul') = pbm_rmul
  local args = array.create(2,2)
        args(1,1) = 'emod'
        args(1,2) = pbm_bemod
        args(2,1) = 'krat'
        args(2,2) = pbm_bkrat
  contact.method(cp, 'pb_deformability', args)
  contact.prop(cp,   'pb_mcf') = pbm_mcf
  contact.prop(cp,   'pb_ten') = ft_valNormDist( pbm_ten_m, pbm_ten_sd )
  contact.prop(cp,   'pb_coh') = ft_valNormDist( pbm_coh_m, pbm_coh_sd )
  contact.prop(cp,   'pb_fa' ) = pbm_fa
end
;------------------------------------------------
fish define _mpAssignPBbond( cp )
  ft_cBondIt( cp )
  if contact.gap(cp) < 0.0 then  ; remove overlap only, do not extend surfaces
    contact.prop(cp, 'rgap') = contact.gap(cp)
  end_if
end
;------------------------------------------------
fish define _mpAssignCBbond( cp )
  ft_cBondIt( cp )
  local args = array.create(2,2)
        args(1,1) = 'tensile'
        args(1,2) = ft_valNormDist( cbm_tens_m,   cbm_tens_sd )
        args(2,1) = 'shear'
        args(2,2) = ft_valNormDist( cbm_shears_m, cbm_shears_sd )
  contact.method(cp, 'cb_strength', args)
  contact.prop(cp, 'rgap') = contact.gap(cp) ; remove overlap or extend surfaces
end
;------------------------------------------------
fish define _mpMakeGrains( seed, nc )
; Generate a cloud of grains with porosity [nc]. This porosity does not account for
; overlaps: nc = (Vv - Vg)/Vg, where Vv is vessel volume and Vg is total grain volume.
; The grains are drawn from the specified size distribution, and then placed at arbitrarily
; chosen positions that lie fully within the material vessel such that there may be large
; grain-grain overlaps.
; PARAMS:
;   seed : seed of random-number generator
;   nc   : cloud porosity (does not account for overlap)
;
  command
    model random [seed]
  end_command
  ;
  if cm_shape == 0 then
    _mpBallDistribute(  seed, nc )
  else  ; cm_shape == 1
    _mpClumpDistribute( seed, nc )
  end_if
end
;------------------------------------------------
fish define _mpBallDistribute( seed, nc )
  mpGrp = array.create( cm_nSD )
  local i
  loop for( i=1, i<=cm_nSD, i=i+1 )
    mpGrp(i) = cm_matName + '-SD' + string(i)
  end_loop
  ;
  local mySize = 7 + 4*cm_nSD
  if mv_shape # 0 then ; mv_shape = {1,2}
    mySize = mySize + 1
  end_if
  local myStr = array.create( mySize )
  myStr(1) = 'ball distribute ...'
  if global.dim == 3 then
    myStr(2) = '  box [-0.5*mv_D] [0.5*mv_D] ...'
    myStr(3) = '      [-0.5*mv_W] [0.5*mv_W] ...'
    myStr(4) = '      [-0.5*mv_H] [0.5*mv_H] ...'
  else ; 2D model
    myStr(2) = '  box [-0.5*mv_W] [0.5*mv_W] ...'
    myStr(3) = '      [-0.5*mv_H] [0.5*mv_H] ...'
    myStr(4) = '      ...'
  end_if
  myStr(5) = '  porosity [nc] ...'
  myStr(6) = '  resolution [cm_Dmult] ...'
  myStr(7) = '  number-bins [cm_nSD] ...'
  loop for( i=1, i<=cm_nSD, i=i+1 )
    local j = 7 + 4*(i-1)
    myStr(j+1) = string.build('  bin %1 group [mpGrp(%2)] ...',i,i)
    myStr(j+2) = string.build('        radius [0.5*cm_Dlo(%1)] [0.5*cm_Dup(%2)] ...',i,i)
    if cm_typeSD(i) == 1 then
      myStr(j+3) = string.build('        gauss ...')
    else
      myStr(j+3) = string.build('        ... ')
    end_if
    myStr(j+4) = string.build('        volume-fraction [cm_Vfrac(%1)]', i)
    if i < cm_nSD then  ; Add ellipses for each entry, but not the last one
      myStr(j+4) = myStr(j+4) + ' ...'
    end_if
  end_loop
  if mv_shape # 0 then ; mv_shape = {1,2}
    myStr(j+4) = myStr(j+4) + ' ...'  ; add ellipses for previous entry
    if mv_shape == 1 then
      myStr(j+5) = '  range fish @_mpCylRange'
    else ; mv_shape = 2
      myStr(j+5) = '  range fish @_mpSphRange'
    end_if
  end_if
  system.command( myStr )
end
;------------------------------------------------
fish define _mpClumpDistribute( seed, nc )
  mpGrp = array.create( cm_nSD )
  local i
  loop for( i=1, i<=cm_nSD, i=i+1 )
    mpGrp(i) = cm_ctName(i) + '-SD' + string(i)
  end_loop
  ;
  local mySize = 8 + 6*cm_nSD
  if mv_shape # 0 then ; mv_shape = {1,2}
    mySize = mySize + 1
  end_if
  local myStr = array.create( mySize )
  myStr(1) = 'clump distribute ...'
  if global.dim == 3 then
    myStr(2) = '  box [-0.5*mv_D] [0.5*mv_D] ...'
    myStr(3) = '      [-0.5*mv_W] [0.5*mv_W] ...'
    myStr(4) = '      [-0.5*mv_H] [0.5*mv_H] ...'
  else ; 2D model
    myStr(2) = '  box [-0.5*mv_W] [0.5*mv_W] ...'
    myStr(3) = '      [-0.5*mv_H] [0.5*mv_H] ...'
    myStr(4) = '      ...'
  end_if
  myStr(5) = '  porosity [nc] ...'
  myStr(6) = '  resolution [cm_Dmult] ...'
  myStr(7) = '  diameter ...'
  myStr(8) = '  number-bins [cm_nSD] ...'
  loop for( i=1, i<=cm_nSD, i=i+1 )
    local j = 8 + 6*(i-1)
    myStr(j+1) = string.build('  bin %1 template [cm_ctName(%2)] ...',i,i)
    myStr(j+2) = string.build('        group [mpGrp(%1)] ...',i)
    myStr(j+3) = string.build('        size [cm_Dlo(%1)] [cm_Dup(%2)] ...',i,i)
    if cm_typeSD(i) == 1 then
      myStr(j+4) = string.build('        gauss ...')
    else
      myStr(j+4) = string.build('        ... ')
    end_if
    myStr(j+5) = string.build('        volume-fraction [cm_Vfrac(%1)] ...', i)
    myStr(j+6) = string.build('        azimuth -180.0 180.0')
    if i < cm_nSD then  ; Add ellipses for each entry, but not the last one
      myStr(j+6) = myStr(j+6) + ' ...'
    end_if
  end_loop
  if mv_shape # 0 then ; mv_shape = {1,2}
    myStr(j+6) = myStr(j+6) + ' ...'  ; add ellipses for previous entry
    if mv_shape == 1 then
      myStr(j+7) = '  range fish @_mpCylRange'
    else ; mv_shape = 2
      myStr(j+7) = '  range fish @_mpSphRange'
    end_if
  end_if
  system.command( myStr )
end
;------------------------------------------------
fish define _mpCylRange( posObj, ptrObj ) ;{i: mv_W, mvWpCyl}
; Fish range element, returns true if the object (ball or clump) is fully inside the cylinder
; wall (which has a polygonal cross section in the xy-plane). The objects lie fully inside the
; cylinder end caps. The wall facets have normals directed toward outside of cylinder.
  local Rs   ; radius of sphere   (ball or pebble)
  local posS ; position of sphere (ball or pebble)
  if type.pointer(ptrObj) == 'ball' then
    local bp = ptrObj
    Rs = ball.radius(bp)
    posS = posObj
    _mpCylRange = _mpCylRangeSup( posS, Rs )
  else if type.pointer(ptrObj) == 'clump' then
    local cl = ptrObj
    loop foreach local pb clump.pebblelist(cl)
      Rs = clump.pebble.radius(pb)
      posS = clump.pebble.pos(pb)
      local _mpCylRangeOUT
      _mpCylRangeOUT = _mpCylRangeSup( posS, Rs )
      _mpCylRange = _mpCylRangeOUT
      if _mpCylRangeOUT == false then
        exit loop
      end_if
    end_loop
  else
    system.error = '_mpCylRange: ptrObj is not a ball or clump.'
  end_if
end
;------------------------------------------------
fish define _mpCylRangeSup( posS, Rs )
; PARAM:
;   posS - position of sphere (ball or pebble)
;   Rs   - radius of sphere (ball or pebble)
;
  ; Test 1: Sphere protrudes from true cylinder.
  local _dsc = math.sqrt( comp.x(posS)*comp.x(posS) + comp.y(posS)*comp.y(posS) )
  local Rc = 0.5*mv_W
  if (_dsc + Rs) > Rc then
    _mpCylRangeSup = false
    exit
  end_if
  ;
  ; Test 2: Sphere center is outside of the nearest facet, thus outside of cylinder.
  local wf = wall.facet.near( posS, mvWpCyl )
  local Pf = wall.facet.pointnear( wf, posS )
  local Psf = posS - Pf
  if math.dot( Psf, wall.facet.normal(wf) ) >= 0.0 then
    _mpCylRangeSup = false
    exit
  end_if
  ;
  ; Test 3: Sphere protrudes from the facet.
  if math.mag(Psf) < Rs then
    _mpCylRangeSup = false
    exit
  end_if
  ;
  _mpCylRangeSup = true
end
;------------------------------------------------
fish define _mpSphRange( posObj, ptrObj ) ;{i: mv_H, mvWpSph}
; Fish range element, returns true if the object (ball or clump) is fully inside the sphere wall.
; The wall facets have normals directed toward inside of sphere.
;
  local Rs   ; radius of sphere   (ball or pebble)
  local posS ; position of sphere (ball or pebble)
  if type.pointer(ptrObj) == 'ball' then
    local bp = ptrObj
    Rs = ball.radius(bp)
    posS = posObj
    _mpSphRange = _mpSphRangeSup( posS, Rs )
  else if type.pointer(ptrObj) == 'clump' then
    local cl = ptrObj
    loop foreach local pb clump.pebblelist(cl)
      Rs = clump.pebble.radius(pb)
      posS = clump.pebble.pos(pb)
      local _mpSphRangeOUT
      _mpSphRangeOUT = _mpSphRangeSup( posS, Rs )
      _mpSphRange = _mpSphRangeOUT
      if _mpSphRangeOUT == false then
        exit loop
      end_if
    end_loop
  else
    system.error = '_mpSphRange: ptrObj is not a ball or clump.'
  end_if
end
;------------------------------------------------
fish define _mpSphRangeSup( posS, Rs )
; PARAM:
;   posS - position of sphere (ball or pebble)
;   Rs   - radius of sphere (ball or pebble)
;
  ; Test 1: Sphere protrudes from true sphere.
  local _dsc = math.sqrt(   comp.x(posS)*comp.x(posS) ...
                          + comp.y(posS)*comp.y(posS) ...
                          + comp.z(posS)*comp.z(posS)     )
  local Rsph = 0.5*mv_H
  if (_dsc + Rs) > Rsph then
    _mpSphRangeSup = false
    exit
  end_if
  ;
  ; Test 2: Sphere center is outside of the nearest facet, thus outside of sphere.
  local wf = wall.facet.near( posS, mvWpSph )
  local Pf = wall.facet.pointnear( wf, posS )
  local Psf = posS - Pf
  if math.dot( Psf, wall.facet.normal(wf) ) <= 0.0 then
    _mpSphRangeSup = false
    exit
  end_if
  ;
  ; Test 3: Sphere protrudes from the facet.
  if math.mag(Psf) < Rs then
    _mpSphRangeSup = false
    exit
  end_if
  ;
  _mpSphRangeSup = true
end
;------------------------------------------------
fish define _mpSetGrainDamp( dFac )
; Set the local-damping factor of all grains to [dFac].
; MODIFY: local-damping factor of all balls and clumps
;
  if ball.num > 0 then
    command
      ball attribute damp [dFac]
    end_command
  end_if
  if clump.num > 0 then
    command
      clump attribute damp [dFac]
    end_command
  end_if
end
;------------------------------------------------
fish define _mpSetGrainDensity
; Set the density of all grains.
;
; IN:     cm_densityCode, cm_densityVal (see Common Material Parameters)
;         mv_shape, mv_{W,H,D}
; MODIFY: density of all balls and clumps
;
  local _rhoG, bp, cp
  if cm_densityCode == 0 then
    _rhoG = cm_densityVal
  else ; cm_densityCode = 1
    local _Vg = 0.0
    loop foreach bp ball.list
      local _bVol
      if global.dim == 3 then
        _bVol = (4.0/3.0)*math.pi*ball.radius(bp)*ball.radius(bp)*ball.radius(bp)
      else ; 2D model
        _bVol = math.pi*ball.radius(bp)*ball.radius(bp)
      end_if
      _Vg = _Vg + _bVol
    end_loop
    loop foreach cl clump.list
      local _cVol = clump.vol(cl)
      _Vg = _Vg + _cVol
    end_loop
    ;
    if _Vg == 0.0 then
      system.error = '_mpSetGrainDensity: Grain volume sum is zero.'
    else
      _rhoG = (cm_densityVal * _mvVolume(true)) / _Vg
    end_if
  end_if
  ;
  loop foreach bp ball.list
    ball.density(bp) = _rhoG
  end_loop
  loop foreach cl clump.list
    clump.density(cl) = _rhoG
  end_loop
end
;------------------------------------------------
fish define _mpCheckAllParams
  _mpCheckCommonParams
  _mpCheckPackingParams
  case_of cm_matType
      system.error = 'cm_matType is not [0,5].'
    case 0
      _mpCheckLinParams
    case 1
      _mpCheckCBParams
    case 2
      _mpCheckPBParams
    case 3
      _mpCheckSBParams
    case 4
      _mpCheckFJParams
    case 5
      udm_checkParams
  end_case
end
;------------------------------------------------
fish define _mpCheckCommonParams
  if type(cm_matName) == 1 then ; it is an integer
    if cm_matName == 0 then ; default (value has not been specified)
      cm_matName = 'PFCmat'
    end_if
  else
    if type(cm_matName) # 3 then
      system.error = 'cm_matName is not a string.'
    else
      if cm_matName == '' then
        cm_matName = 'PFCmat'
      end_if
    end_if
  end_if
  ;
  if type(cm_matNameSAV) == 1 then ; it is an integer
    if cm_matNameSAV == 0 then ; default (value has not been specified)
      cm_matNameSAV = 'PFCmat'
    end_if
  else
    if type(cm_matNameSAV) # 3 then
      system.error = 'cm_matNameSAV is not a string.'
    else
      if cm_matNameSAV == '' then
        cm_matNameSAV = 'PFCmat'
      end_if
    end_if
  end_if
  ;
  if (cm_matType < 0) | (cm_matType > 5) then
    system.error = 'cm_matType is not [0,5].'
  end_if
  ;
  if cm_matType == 5 then ; user-defined material
    if type(cm_modName) # 3 then
      system.error = 'cm_modName is not a string.'
    else
      if cm_modName == '' then
        system.error = 'cm_modName must be specified.'
      end_if
    end_if
  end_if
  ;
  if cm_localDampFac == 0 then ; default
    cm_localDampFac = float(0.0)
  else
    if cm_localDampFac < 0.0 then
      system.error = 'cm_localDampFac must be in range [0.0, 0.7].'
    end_if
    if cm_localDampFac > 0.7 then
      system.error = 'cm_localDampFac must be in range [0.0, 0.7].'
    end_if
  end_if
  ;
  if cm_densityCode # 0 then
    if cm_densityCode # 1 then
      system.error = 'cm_densityCode must be {0,1}.'
    end_if
  end_if
  if cm_densityVal == 0 then ; default
    system.error = 'cm_densityVal must be specified.'
  else
    if cm_densityVal <= 0.0 then
      system.error = 'cm_densityVal must be greater than or equal to zero.'
    end_if
  end_if
  ;
  ; **** Grain shape & size distribution group:
  if (cm_shape < 0) | (cm_shape > 1) then
    system.error = 'cm_shape must be {0,1}.'
  end_if
  if (mv_type == 1) & (cm_shape == 1) then
    system.error = 'Cannot yet create clumps in a periodic vessel, must fix _GSgetAlpha.'
  end_if
  ;
  if cm_nSD == 0 then ; default
    cm_nSD = 1
  else
    if cm_nSD < 1 then
      system.error = 'cm_nSD must be greater than or equal to one.'
    end_if
  end_if
  ;
  local i
  local Vfrac = 0.0
  loop for( i=1, i<=cm_nSD, i=i+1 )
    if cm_typeSD(i) # 0 then
      if cm_typeSD(i) # 1 then
        system.error = 'cm_typeSD(' + string(i) + ') must be {0,1}.'
      end_if
    end_if
    ;
    if cm_shape == 1 then
      if type( cm_ctName(i) ) # 3 then ; it is not a string
        system.error = 'cm_ctName(' + string(i) + ') must be specified.'
      end_if
    end_if
    ;
    if cm_Dlo(i) == 0 then ; default
      system.error = 'cm_Dlo(' + string(i) + ') must be specified.'
    else
      if cm_Dlo(i) <= 0.0 then
        system.error = 'cm_Dlo(' + string(i) + ') must be greater than zero.'
      end_if
    end_if
    ;
    if cm_Dup(i) == 0 then ; default
      system.error = 'cm_Dup(' + string(i) + ') must be specified.'
    else
      if cm_Dup(i) <= 0.0 then
        system.error = 'cm_Dup(' + string(i) + ') must be greater than zero.'
      end_if
    end_if
    if cm_Dup(i) < cm_Dlo(i) then
      system.error = 'cm_Dup(' + string(i) + ') must be >= cm_Dlo(' + string(i) + ').'
    end_if
    ;
    if cm_Vfrac(i) == 0 then ; default
      system.error = 'cm_Vfrac(' + string(i) + ') must be specified and cannot be zero.'
    else
      if cm_Vfrac(i) <= 0.0 then
        system.error = 'cm_Vfrac(' + string(i) + ') must be greater than zero.'
      end_if
    end_if
    Vfrac = Vfrac + cm_Vfrac(i)
  end_loop
  if math.abs(Vfrac - 1.0) > _ftCheckZeroTol then
    system.error = 'cm_Vfrac() = ' + string(Vfrac) + ', which does not sum to one.'
  end_if
  ;
  if cm_Dmult == 0 then ; default
    cm_Dmult = 1.0
  else
    if cm_Dmult <= 0.0 then
      system.error = 'cm_Dmult must be greater than zero.'
    end_if
  end_if
end
;------------------------------------------------
fish define _mpCheckPackingParams
  pk_seed = int(pk_seed)
  if pk_seed == 0 then ; default
    pk_seed = 10000
  else
    if pk_seed < 10000 then
      system.error = 'pk_seed must be greater than or equal to 10000.'
    end_if
  end_if
  ;
  if pk_Pm == 0 then ; default
    system.error = 'pk_Pm must be specified.'
  else
    if pk_Pm <= 0.0 then
      system.error = 'pk_Pm must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pk_PTol == 0 then ; default
    pk_PTol = 1e-2
  else
    if pk_PTol <= 0.0 then
      system.error = 'pk_PTol must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pk_ARatLimit == 0 then ; default
    pk_ARatLimit = 8e-3
  else
    if pk_ARatLimit <= 0.0 then
      system.error = 'pk_ARatLimit must be greater than zero.'
    end_if
  end_if
  ;
  if pk_stepLimit == 0 then ; default
    pk_stepLimit = 2000000 ; 2 million
  else
    if pk_stepLimit < 1 then
      system.error = 'pk_stepLimit must be greater than or equal to one.'
    end_if
  end_if
  ;
  if (pk_procCode < 0) | (pk_procCode > 1) then
    system.error = 'pk_procCode must be {0,1}.'
  end_if
  if (mv_type == 1) & (pk_procCode == 0) then
    system.error = 'Boundary contraction packing procedure not available for periodic vessel.'
  end_if
  ;
  if pk_nc == 0 then ; default
    if global.dim == 3 then
      if pk_procCode == 0 then
        pk_nc = 0.58
      else ; mp_procCode = 1
        pk_nc = 0.35
      end_if
    else ; 2D model
      if pk_procCode == 0 then
        pk_nc = 0.25
      else ; mp_procCode = 1
        pk_nc = 0.08
      end_if
    end_if
  end_if
  if pk_nc <= 0.0 then
    system.error = 'pk_nc must be greater than zero.'
  end_if
  if pk_nc >= 1.0 then
    system.error = 'pk_nc must be less than one.'
  end_if
  ;
  if pk_procCode == 0 then
    if pk_fricCA == 0 then ; default
      pk_fricCA = float(0.0)
    else
      if pk_fricCA < 0.0 then
        system.error = 'pk_fricCA must be greater than or equal to zero.'
      end_if
    end_if
    ;
    if pk_vLimit == 0 then ; default
      system.error = 'Must specify pk_vLimit.'
    else
      if pk_vLimit <= 0.0 then
        system.error = 'pk_vLimit must be greater than zero.'
      end_if
    end_if
  end_if
  ;
  if _pkORmaxLimit == 0 then ; default
    _pkORmaxLimit = 0.25
  else
    if _pkORmaxLimit <= 0.0 then
      system.error = '_pkORmaxLimit must be greater than or equal to zero.'
    end_if
    if _pkORmaxLimit > 2.0 then
      system.error = '_pkORmaxLimit must be less than or equal to two.'
    end_if
  end_if
  ;
  if _pkORupdateRate == 0 then ; default
    _pkORupdateRate = 100
  else
    if _pkORupdateRate < 1 then
      system.error = '_pkORupdateRate must be greater than or equal to one.'
    end_if
  end_if
end
;------------------------------------------------
fish define _mpCheckLinParams
  if lnm_emod == 0 then ; default
    lnm_emod = float(0.0)
  else
    if lnm_emod < 0.0 then
      system.error = 'lnm_emod must be greater than or equal to zero.'
    end_if
  end_if
  if lnm_krat == 0 then  ; default
    lnm_krat = float(0.0)
  else
    if lnm_krat < 0.0 then
      system.error = 'lnm_krat must be greater than or equal to zero.'
    end_if
  end_if
  if lnm_fric == 0 then  ; default
    lnm_fric = float(0.0)
  else
    if lnm_fric < 0.0 then
      system.error = 'lnm_fric must be greater than or equal to zero.'
    end_if
  end_if
end
;------------------------------------------------
fish define _mpCheckPBParams
  ; Parallel-bonded material group: Linear group:
  if pbm_emod == 0 then ; default
    pbm_emod = float(0.0)
  else
    if pbm_emod < 0.0 then
      system.error = 'pbm_emod must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_krat == 0 then ; default
    pbm_krat = float(0.0)
  else
    if pbm_krat < 0.0 then
      system.error = 'pbm_krat must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_fric == 0 then ; default
    pbm_fric = float(0.0)
  else
    if pbm_fric < 0.0 then
      system.error = 'pbm_fric must be greater than or equal to zero.'
    end_if
  end_if
  ; **********************
  ; Parallel-bonded material group: Parallel-bond group:
  if pbm_igap == 0 then ; default
    pbm_igap = float(0.0)
  else
    if pbm_igap < 0.0 then
      system.error = 'pbm_igap must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_rmul == 0 then ; default
    pbm_rmul = float(1.0)
  else
    if pbm_rmul <= 0.0 then
      system.error = 'pbm_rmul must be greater than zero.'
    end_if
  end_if
  ;
  if pbm_bemod == 0 then ; default
    pbm_bemod = float(0.0)
  else
    if pbm_bemod < 0.0 then
      system.error = 'pbm_bemod must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_bkrat == 0 then ; default
    pbm_bkrat = float(0.0)
  else
    if pbm_bkrat < 0.0 then
      system.error = 'pbm_bkrat must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_mcf == 0 then ; default
    pbm_mcf = float(0.0)
  else
    if (pbm_mcf < 0.0) | (pbm_mcf > 1.0) then
      system.error = 'pbm_mcf must be in range [0.0, 1.0].'
    end_if
  end_if
  ;
  if pbm_ten_m == 0 then ; default
    pbm_ten_m = float(0.0)
  else
    if pbm_ten_m < 0.0 then
      system.error = 'pbm_ten_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_ten_sd == 0 then ; default
    pbm_ten_sd = float(0.0)
  else
    if pbm_ten_sd < 0.0 then
      system.error = 'pbm_ten_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_coh_m == 0 then ; default
    pbm_coh_m = float(0.0)
  else
    if pbm_coh_m < 0.0 then
      system.error = 'pbm_coh_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_coh_sd == 0 then ; default
    pbm_coh_sd = float(0.0)
  else
    if pbm_coh_sd < 0.0 then
      system.error = 'pbm_coh_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if pbm_fa == 0 then ; default
    pbm_fa = float(0.0)
  else
    if pbm_fa < 0.0 then
      system.error = 'pbm_fa must be greater than or equal to zero, in range [0.0,  90.0).'
    end_if
    if pbm_fa >= 90.0 then
      system.error = 'pbm_fa must be less than ninety, in range [0.0,  90.0).'
    end_if
  end_if
  ; **********************
  ; Linear material group:
  _mpCheckLinParams
end
;------------------------------------------------
fish define _mpCheckSBParams
  ; Soft-bonded material group:
  if sbm_igap == 0 then ; default
    sbm_igap = float(0.0)
  else
    if sbm_igap < 0.0 then
      system.error = 'sbm_igap must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_rmul == 0 then ; default
    sbm_rmul = float(1.0)
  else
    if sbm_rmul <= 0.0 then
      system.error = 'sbm_rmul must be greater than zero.'
    end_if
  end_if
  ;
  if sbm_emod == 0 then ; default
    sbm_emod = float(0.0)
  else
    if sbm_emod < 0.0 then
      system.error = 'sbm_emod must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_bkrat == 0 then ; default
    sbm_bkrat = float(0.0)
  else
    if sbm_bkrat < 0.0 then
      system.error = 'sbm_bkrat must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_mcf == 0 then ; default
    sbm_mcf = float(0.0)
  else
    if (sbm_mcf < 0.0) | (sbm_mcf > 1.0) then
      system.error = 'sbm_mcf must be in range [0.0, 1.0].'
    end_if
  end_if
  ;
  if sbm_ten_m == 0 then ; default
    sbm_ten_m = float(0.0)
  else
    if sbm_ten_m < 0.0 then
      system.error = 'sbm_ten_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_ten_sd == 0 then ; default
    sbm_ten_sd = float(0.0)
  else
    if sbm_ten_sd < 0.0 then
      system.error = 'sbm_ten_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_coh_m == 0 then ; default
    sbm_coh_m = float(0.0)
  else
    if sbm_coh_m < 0.0 then
      system.error = 'sbm_coh_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_coh_sd == 0 then ; default
    sbm_coh_sd = float(0.0)
  else
    if sbm_coh_sd < 0.0 then
      system.error = 'sbm_coh_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_fa == 0 then ; default
    sbm_fa = float(0.0)
  else
    if sbm_fa < 0.0 then
      system.error = 'sbm_fa must be greater than or equal to zero, in range [0.0,  90.0).'
    end_if
    if sbm_fa >= 90.0 then
      system.error = 'sbm_fa must be less than ninety, in range [0.0,  90.0).'
    end_if
  end_if
  ;
  if sbm_soft == 0 then ; default
    sbm_soft = float(0.0)
  else
    if sbm_soft < 0.0 then
      system.error = 'sbm_soft must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_cut == 0 then ; default
    sbm_cut = float(0.0)
  else
    if (sbm_cut < 0.0) | (sbm_cut > 1.0) then
      system.error = 'sbm_cut must be in range [0.0, 1.0].'
    end_if
  end_if
  ;
  if sbm_fric == 0 then ; default
    sbm_fric = float(0.0)
  else
    if sbm_fric < 0.0 then
      system.error = 'sbm_fric must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_bmul == 0 then ; default
    sbm_bmul = float(0.0)
  else
    if sbm_bmul < 0.0 then
      system.error = 'sbm_bmul must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if sbm_tmul == 0 then ; default
    sbm_tmul = float(0.0)
  else
    if sbm_tmul < 0.0 then
      system.error = 'sbm_tmul must be greater than or equal to zero.'
    end_if
  end_if
  ; **********************
  ; Linear material group:
  _mpCheckLinParams
end
;------------------------------------------------
fish define _mpCheckCBParams
  ; Contact-bonded material group: Linear group:
  if cbm_emod == 0 then ; default
    cbm_emod = float(0.0)
  else
    if cbm_emod < 0.0 then
      system.error = 'cbm_emod must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if cbm_krat == 0 then ; default
    cbm_krat = float(0.0)
  else
    if cbm_krat < 0.0 then
      system.error = 'cbm_krat must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if cbm_fric == 0 then ; default
    cbm_fric = float(0.0)
  else
    if cbm_fric < 0.0 then
      system.error = 'cbm_fric must be greater than or equal to zero.'
    end_if
  end_if
  ; **********************
  ; Contact-bonded material group: Contact-bond group:
  if cbm_igap == 0 then ; default
    cbm_igap = float(0.0)
  else
    if cbm_igap < 0.0 then
      system.error = 'cbm_igap must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if cbm_tens_m == 0 then ; default
    cbm_tens_m = float(0.0)
  else
    if cbm_tens_m < 0.0 then
      system.error = 'cbm_tens_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if cbm_tens_sd == 0 then ; default
    cbm_tens_sd = float(0.0)
  else
    if cbm_tens_sd < 0.0 then
      system.error = 'cbm_tens_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if cbm_shears_m == 0 then ; default
    cbm_shears_m = float(0.0)
  else
    if cbm_shears_m < 0.0 then
      system.error = 'cbm_shears_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if cbm_shears_sd == 0 then ; default
    cbm_shears_sd = float(0.0)
  else
    if cbm_shears_sd < 0.0 then
      system.error = 'cbm_shears_sd must be greater than or equal to zero.'
    end_if
  end_if
  ; **********************
  ; Linear material group:
  _mpCheckLinParams
end
;------------------------------------------------
fish define _mpCheckFJParams
  ; **********************
  ; Flat-jointed material group:
  ; fjm_trackMS has default of 0, which is false
  if fjm_igap == 0 then ; default
    fjm_igap = float(0.0)
  else
    if fjm_igap < 0.0 then
      system.error = 'fjm_igap must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_B_frac < 0.0 then
    system.error = 'fjm_B_frac must be greater than or equal to zero.'
  else if fjm_B_frac > 1.0 then
    system.error = 'fjm_B_frac must be less than or equal to one.'
  end_if
  if fjm_G_frac < 0.0 then
    system.error = 'fjm_G_frac must be greater than or equal to zero.'
  else if fjm_G_frac > 1.0 then
    system.error = 'fjm_G_frac must be less than or equal to one.'
  end_if
  fjm_S_frac = 1.0 - fjm_B_frac - fjm_G_frac
  if fjm_S_frac < 0.0 then
    if math.abs(fjm_S_frac) > _ftCheckZeroTol then
      system.error = 'fjm_S_frac must be greater than or equal to zero.'
    end_if
  else if fjm_S_frac > 1.0 then
    system.error = 'fjm_S_frac must be less than or equal to one.'
  end_if
  local fracSum = fjm_B_frac + fjm_G_frac + fjm_S_frac
  if math.abs( fracSum - 1.0 ) > _ftCheckZeroTol then
    system.error = 'fjm_{B,G,S}_frac do not sum to one.'
  end_if
  ;
  if fjm_G_m == 0 then ; default
    fjm_G_m = float(0.0)
  else
    if fjm_G_m < 0.0 then
      system.error = 'fjm_G_m must be greater than or equal to zero.'
    end_if
  end_if
  if fjm_G_sd == 0 then ; default
    fjm_G_sd = float(0.0)
  else
    if fjm_G_sd < 0.0 then
      system.error = 'fjm_G_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_Nr == 0 then ; default
    fjm_Nr = 2
  else
    if fjm_Nr < 1 then
      system.error = 'fjm_Nr must be greater than or equal to one.'
    end_if
  end_if
  if global.dim == 3 then
    if fjm_Nal == 0 then ; default
      fjm_Nal = 4
    else
      if fjm_Nal < 3 then
        system.error = 'fjm_Nal must be greater than or equal to three.'
      end_if
    end_if
  end_if
  ;
  if fjm_rmulCode # 0 then
    if fjm_rmulCode # 1 then
      if fjm_rmulCode # 2 then
        system.error = 'fjm_rmulCode must be {0,1,2}.'
      end_if
    end_if
  end_if
  ;
  if fjm_rmulVal == 0 then ; default
    fjm_rmulVal = float(1.0)
  else
    if fjm_rmulVal <= 0.0 then
      system.error = 'fjm_rmulVal must be greater than zero.'
    end_if
  end_if
  ;
  if fjm_emod == 0 then ; default
    fjm_emod = float(0.0)
  else
    if fjm_emod < 0.0 then
      system.error = 'fjm_emod must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_krat == 0 then ; default
    fjm_krat = float(0.0)
  else
    if fjm_krat < 0.0 then
      system.error = 'fjm_krat must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_fric == 0 then ; default
    fjm_fric = float(0.0)
  else
    if fjm_fric < 0.0 then
      system.error = 'fjm_fric must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_ten_m == 0 then ; default
    fjm_ten_m = float(0.0)
  else
    if fjm_ten_m < 0.0 then
      system.error = 'fjm_ten_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_ten_sd == 0 then ; default
    fjm_ten_sd = float(0.0)
  else
    if fjm_ten_sd < 0.0 then
      system.error = 'fjm_ten_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_coh_m == 0 then ; default
    fjm_coh_m = float(0.0)
  else
    if fjm_coh_m < 0.0 then
      system.error = 'fjm_coh_m must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_coh_sd == 0 then ; default
    fjm_coh_sd = float(0.0)
  else
    if fjm_coh_sd < 0.0 then
      system.error = 'fjm_coh_sd must be greater than or equal to zero.'
    end_if
  end_if
  ;
  if fjm_fa == 0 then ; default
    fjm_fa = float(0.0)
  else
    if fjm_fa < 0.0 then
      system.error = 'fjm_fa must be greater than or equal to zero, in range [0.0,  90.0).'
    end_if
    if fjm_fa >= 90.0 then
      system.error = 'fjm_fa must be less than ninety, in range [0.0,  90.0).'
    end_if
  end_if
  ; **********************
  ; Linear material group:
  _mpCheckLinParams
end
;------------------------------------------------
fish define udm_checkParams
; If cm_matType == 5 then
;   check parameters of the user-defined material.
;
  local myStr =         'The FISH function udm_checkParams must be provided by user'
        myStr = myStr + ' when cm_matType == 5. This is done by redefining the function.'
  system.error = myStr
end
;------------------------------------------------
fish define mpListMicroProps
  io.out('## Material Microproperties:')
  ;
  mpListCommonProps
  mpListPackingProps
  case_of cm_matType
      system.error = 'cm_matType is not [0,5].'
    case 0
      mpListLinProps
    case 1
      mpListCBProps
    case 2
      mpListPBProps
    case 3
      mpListSBProps
    case 4
      mpListFJProps
    case 5
      udm_listProps
  end_case
end
;------------------------------------------------
fish define mpListCommonProps
  io.out('   Common group:')
  ;
  io.out('     cm_matName (material name, for model title): ' + string(cm_matName))
  io.out('     cm_matNameSAV (material name, for SAV file names): ' + string(cm_matNameSAV))
  local _str = '     cm_matType (material-type code): '+string(cm_matType)
  case_of cm_matType
      system.error = 'cm_matType is not [0,5].'
    case 0
      _str = _str + ' (linear)'
    case 1
      _str = _str + ' (contact-bonded)'
    case 2
      _str = _str + ' (parallel-bonded)'
    case 3
      _str = _str + ' (soft-bonded)'
    case 4
      _str = _str + ' (flat-jointed)'
    case 5
      _str = _str + ' (user-defined)'
  end_case
  io.out(_str)
  if cm_matType == 5 then ; user-defined material
    io.out('     cm_modName (contact-model name): ' + string(cm_modName))
  end_if
  ;
  io.out('     cm_localDampFac (local-damping factor): ' + string(cm_localDampFac))
  ;
  _str = '     cm_densityCode: ' + string(cm_densityCode)
  if cm_densityCode == 0 then
    _str = _str + ' (cm_densityVal is grain density)'
  else ; cm_densityCode = 1
    _str = _str + ' (cm_densityVal is bulk density)'
  end_if
  io.out(_str)
  io.out('     cm_densityVal: ' + string(cm_densityVal))
  ;
  io.out('     Grain shape & size distribution group:')
  _str = '       cm_shape (grain-shape code): ' + string(cm_shape)
  case_of cm_shape
    system.error = 'cm_shape is not {0,1}.'
    case 0
      _str = _str + ' (all balls)'
    case 1
      _str = _str + ' (all clumps)'
  end_case
  io.out(_str)
  ;
  io.out('       cm_nSD (number of size distributions): ' + string(cm_nSD))
  ;
  local i
  loop for( i=1, i<=cm_nSD, i=i+1 )
    _str = '         cm_typeSD('+string(i)+'): '
    case_of cm_typeSD(i)
      case 0
        _str = _str + '0 (uniform)'
      case 1
        _str = _str + '1 (gaussian)'
    end_case
    io.out(_str)
    if cm_shape == 1 then
      io.out('         cm_ctName('+string(i)+'): '+string(cm_ctName(i)))
    end_if
    io.out('         cm_Dlo('+string(i)+'): '+string(cm_Dlo(i)))
    io.out('         cm_Dup('+string(i)+'): '+string(cm_Dup(i)))
    io.out('         cm_Vfrac('+string(i)+'): '+string(cm_Vfrac(i)))
    if i < cm_nSD then
      io.out('           --------------------------')
    end_if
  end_loop
  ;
  io.out('       cm_Dmult (diameter multiplier): ' + string(cm_Dmult))
end
;------------------------------------------------
fish define mpListPackingProps
  io.out('   Packing group:')
  io.out('     pk_seed (seed of random-number generator): ' + string(pk_seed))
  io.out('     pk_Pm (material pressure): ' + string(pk_Pm))
  io.out('     pk_PTol (pressure tolerance): ' + string(pk_PTol))
  io.out('     pk_ARatLimit (equilibrium-ratio limit): ' + string(pk_ARatLimit))
  io.out('     pk_stepLimit (step limit): ' + string(pk_stepLimit))
  ;
  _str = '     pk_procCode (packing-procedure code): ' + string(pk_procCode)
  if pk_procCode == 0 then
    _str = _str + ' (boundary contraction)'
  else
    _str = _str + ' (grain scaling)'
  end_if
  io.out( _str )
  ;
  io.out('     pk_nc (grain-cloud porosity): ' + string(pk_nc))
  if pk_procCode == 0 then
    io.out('     Boundary-contraction group:')
    io.out('       pk_fricCA (material friction coef. during confinement application): '...
                   + string(pk_fricCA))
    io.out('       pk_vLimit (servo velocity limit): ' + string(pk_vLimit))
  end_if
  ;
  io.out('     _pkORmaxLimit (overlap-ratio maximum limit): ' + string(_pkORmaxLimit))
  io.out('     _pkORupdateRate (overlap-ratio update rate, number of cycles): ' + string(_pkORupdateRate))
end
;------------------------------------------------
fish define mpListLinProps
  io.out('   Linear material group:')
  io.out('     lnm_emod (effective modulus): ' + string(lnm_emod))
  io.out('     lnm_krat (stiffness ratio): ' + string(lnm_krat))
  io.out('     lnm_fric (friction coefficient): ' + string(lnm_fric))
end
;------------------------------------------------
fish define mpListCBProps
  io.out('   Contact-bonded material group:')
  io.out('     Linear group:')
  io.out('       cbm_emod (effective modulus): ' + string(cbm_emod))
  io.out('       cbm_krat (stiffness ratio): ' + string(cbm_krat))
  io.out('       cbm_fric (friction coefficient): ' + string(cbm_fric))
  ;
  io.out('     Contact-bond group:')
  io.out('       cbm_igap (installation gap): ' + string(cbm_igap))
  io.out('       cbm_tens_m    (tensile-strength distribution [stress], mean): ' + string(cbm_tens_m))
  io.out('       cbm_tens_sd   (tensile-strength distribution [stress], standard deviation): ' + string(cbm_tens_sd))
  io.out('       cbm_shears_m  (shear-strength   distribution [stress], mean): ' + string(cbm_shears_m))
  io.out('       cbm_shears_sd (shear-strength   distribution [stress], standard deviation): ' + string(cbm_shears_sd))
  ;
  mpListLinProps
end
;------------------------------------------------
fish define mpListPBProps
  io.out('   Parallel-bonded material group:')
  io.out('     Linear group:')
  io.out('       pbm_emod (effective modulus): ' + string(pbm_emod))
  io.out('       pbm_krat (stiffness ratio): ' + string(pbm_krat))
  io.out('       pbm_fric (friction coefficient): ' + string(pbm_fric))
  ;
  io.out('     Parallel-bond group:')
  io.out('       pbm_igap (installation gap): ' + string(pbm_igap))
  io.out('       pbm_rmul (radius multiplier): ' + string(pbm_rmul))
  io.out('       pbm_bemod (bond effective modulus): ' + string(pbm_bemod))
  io.out('       pbm_bkrat (bond stiffness ratio): ' + string(pbm_bkrat))
  io.out('       pbm_mcf (moment-contribution factor): ' + string(pbm_mcf))
  io.out('       pbm_ten_m  (tensile-strength distribution, mean): ' + string(pbm_ten_m))
  io.out('       pbm_ten_sd (tensile-strength distribution, standard deviation): ' + string(pbm_ten_sd))
  io.out('       pbm_coh_m  (cohesion distribution, mean): ' + string(pbm_coh_m))
  io.out('       pbm_coh_sd (cohesion distribution, standard deviation): ' + string(pbm_coh_sd))
  io.out('       pbm_fa (friction angle [degrees]): ' + string(pbm_fa))
  ;
  mpListLinProps
end
;------------------------------------------------
fish define mpListSBProps
  io.out('   Soft-bonded material group:')
  ;
  io.out('     sbm_igap (installation gap): ' + string(sbm_igap))
  io.out('     sbm_rmul (radius multiplier): ' + string(sbm_rmul))
  io.out('     sbm_emod (effective modulus): ' + string(sbm_emod))
  io.out('     sbm_krat (stiffness ratio): ' + string(sbm_krat))
  io.out('     sbm_mcf (moment-contribution factor): ' + string(sbm_mcf))
  io.out('     sbm_ten_m  (tensile-strength distribution, mean): ' + string(sbm_ten_m))
  io.out('     sbm_ten_sd (tensile-strength distribution, standard deviation): ' + string(sbm_ten_sd))
  io.out('     sbm_coh_m  (cohesion distribution, mean): ' + string(sbm_coh_m))
  io.out('     sbm_coh_sd (cohesion distribution, standard deviation): ' + string(sbm_coh_sd))
  io.out('     sbm_fa (friction angle [degrees]): ' + string(sbm_fa))
  io.out('     sbm_soft (softening factor): ' + string(sbm_soft))
  io.out('     sbm_cut (strength-reduction factor): ' + string(sbm_cut))
  io.out('     sbm_fric (friction coefficient, when unbonded): ' + string(sbm_fric))
  io.out('     sbm_bmul ( bending-friction multiplier, when unbonded): ' + string(sbm_bmul))
  io.out('     sbm_tmul (twisting-friction multiplier, when unbonded): ' + string(sbm_tmul))
  ;
  mpListLinProps
end
;------------------------------------------------
fish define mpListFJProps
  io.out('   Flat-jointed material group:')
  io.out('     fjm_trackMS (microstructure-tracking flag): ' + string(fjm_trackMS))
  io.out('     fjm_igap (installation gap): ' + string(fjm_igap))
  io.out('     fjm_B_frac (bonded fraction): ' + string(fjm_B_frac))
  io.out('     fjm_G_frac (gapped fraction): ' + string(fjm_G_frac))
  io.out('     fjm_S_frac (slit fraction, derived): ' + string(fjm_S_frac))
  io.out('     fjm_G_m  (initial surface-gap distribution, mean): ' + string(fjm_G_m))
  io.out('     fjm_G_sd (initial surface-gap distribution, standard deviation): ' + string(fjm_G_sd))
  if global.dim == 3 then
    io.out('     fjm_Nr  (elements in radial direc.): ' + string(fjm_Nr))
    io.out('     fjm_Nal (elements in circumferential direc.): ' + string(fjm_Nal))
  else ; 2D model
    io.out('     fjm_Nr  (total number of elements): ' + string(fjm_Nr))
  end_if
  local myStr = '     fjm_rmulCode (radius-multiplier code): '+string(fjm_rmulCode)+','
  if fjm_rmulCode == 0 then
    myStr = myStr + ' lambda constant (no valid check)'
  else if fjm_rmulCode == 1 then
    myStr = myStr + ' valid via lambda non-uniform reduce'
  else ; fjm_rmulCode == 2
    myStr = myStr + ' valid* via lambda uniform reduce'
  end_if
  io.out( myStr )
  io.out('     fjm_rmulVal  (radius-multiplier value): ' + string(fjm_rmulVal))
  io.out('     fjm_emod (effective modulus): ' + string(fjm_emod))
  io.out('     fjm_krat (stiffness ratio): ' + string(fjm_krat))
  io.out('     fjm_fric (friction coefficient): ' + string(fjm_fric))
  io.out('     fjm_ten_m  (tensile-strength distribution, mean): ' + string(fjm_ten_m))
  io.out('     fjm_ten_sd (tensile-strength distribution, standard deviation): ' + string(fjm_ten_sd))
  io.out('     fjm_coh_m  (cohesion distribution, mean): ' + string(fjm_coh_m))
  io.out('     fjm_coh_sd (cohesion distribution, standard deviation): ' + string(fjm_coh_sd))
  io.out('     fjm_fa (friction angle [degrees]): ' + string(fjm_fa))
  ;
  mpListLinProps
end
;------------------------------------------------
fish define udm_ListProps
; If cm_matType == 5 then
;   list properties of the user-defined material.
;
  local myStr =         'The FISH function udm_listProps must be provided by user'
        myStr = myStr + ' when cm_matType == 5. This is done by redefining the function.'
  system.error = myStr
end
;------------------------------------------------
fish define mpListMicroStrucProps
  io.out('## Material Microstructural Properties [# is "number of"]:')
  mpComputeMicroStrucProps
  ; ********************
  io.out('   Grain Size and Packing Information:')
  io.out('     mp_nGN (# grains): '+string(mp_nGN))
  io.out('     Grain-size distribution (GSD) via gsdMeasure(numBins) to create table GSD, ')
  io.out('       which is displayed in view pl-GSD.')
  io.out('     mp_Davg               (average grain diameter): '+string(mp_Davg))
  io.out('     mp_D50                ( median grain diameter): '+string(mp_D50))
  io.out('     mp_PhiVavg (vessel resolution w.r.t. mp_Davg ): '+string(mp_PhiVavg))
  io.out('     mp_PhiV50  (vessel resolution w.r.t. mp_D50  ): '+string(mp_PhiV50))
  io.out('     mv_mn (measurement-based porosity): '+string(mv_mn))
  local myStr = '     mp_ORs (overlap ratios {max, min, avg}): '
        myStr = myStr + string('{')
        myStr = myStr + string(mp_ORmax) + string(',')
        myStr = myStr + string(mp_ORmin) + string(',')
        myStr = myStr + string(mp_ORavg) + string('}')
  io.out(myStr)
  ; ********************
  io.out('   Contact Information:')
  io.out('     mp_nLNc  (# active linear-based             contacts): '+string(mp_nLNc))
  io.out('     mp_nLNgg (# active linear-based grain-grain contacts): '+string(mp_nLNgg))
  io.out('     mp_nLNgw (# active linear-based grain-wall  contacts): '+string(mp_nLNgw))
  ; ********************
  if ft_mBonded then ; bonded material
    io.out('   Bonded-Material Information:')
    io.out('     mp_CNb (bond coordination number via bcnMeasure): '+string(mp_CNb))
    io.out('     mp_nCBb  (# contact-bonded  bonds): '+string(mp_nCBb))
    io.out('     mp_nPBb  (# parallel-bonded bonds): '+string(mp_nPBb))
    io.out('     mp_nSBb  (# soft-bonded     bonds): '+string(mp_nSBb))
    io.out('     mp_nFJc  (# flat-jointed contacts): '+string(mp_nFJc))
    io.out('     mp_nFJe  (# flat-jointed elements): '+string(mp_nFJe))
    io.out('     mp_nFJb  (# flat-jointed    bonds): '+string(mp_nFJb))
    if cm_matType == 4 then ; flat-jointed material
      io.out('     Initial microstructural types of flat-jointed material:')
      io.out('       mp_nFJiB (# FJs initially bonded): '+string(mp_nFJiB))
      io.out('       mp_nFJiG (# FJs initially gapped): '+string(mp_nFJiG))
      io.out('       mp_nFJiS (# FJs initially   slit): '+string(mp_nFJiS))
      io.out('       mp_nFJiU (# FJs initially undef.): '+string(mp_nFJiU))
    end_if
  end_if
  ; ********************
  if cm_matType == 5 then ; user-defined material
    io.out('   User-Defined Material Information:')
    udm_computeMicroStrucProps
    udm_listMicroStrucProps
  end_if
end
;------------------------------------------------
fish define udm_listMicroStrucProps
; If cm_matType == 5 then
;   list microstructural properties of the user-defined material.
;
  local myStr =         'The FISH function udm_listMicroStrucProps must be provided by user'
        myStr = myStr + ' when cm_matType == 5. This is done by redefining the function.'
  system.error = myStr
end
;------------------------------------------------
fish define mpDavg
; Return average grain diameter (equals -1.0 if problem measuring it).
;
  local nGN = ball.num + clump.num
  local cntG = 0
  local sumD = 0.0
  loop foreach local bp ball.list
    cntG = cntG + 1
    sumD = sumD + 2.0*ball.radius(bp)
  end_loop
  loop foreach local cl clump.list
    cntG = cntG + 1
    sumD = sumD + _clDiam(cl)
  end_loop
  if cntG # nGN then
    system.error = 'Logic error in mpDavg.'
  end_if
  if cntG # 0 then
    mpDavg = sumD / float(cntG)
  else
    mpDavg = -1.0
  end_if
end
;------------------------------------------------
fish define mpComputeMicroStrucProps
; Compute the microstructural properties of the material, store in global variables and
; in table GSD.
;
; OUT: mp_nGN     : number of grains in model, where a grain is a ball or clump
;      table GSD  : grain size distribution (additional GSD info. in tables GSD-X)
;      mp_Davg    : see mpDavg
;      mp_D50     : median grain diameter (sieve size that 50 percent of the grains can pass through
;                    and these grains comprise 50 percent of the total mass)
;      mp_PhiVavg : vessel resolution w.r.t. average grain diameter
;      mp_PhiV50  : vessel resolution w.r.t. median grain diameter
;      mp_OR{max,min,avg} : overlap ratios (defined in ft_OverlapRatios)
;      mp_CNb     : bond coordination number (defined in bcnMeasure)
;      mp_nLN{c,gg,gw}, nFJc, mp_n{CB,PB,SB,FJ}b, mp_nFJi{B,G,S,U} : see mpListMicroStrucProps
;
  mp_nGN = ball.num + clump.num
  gsdMeasure( 79 ) ; odd number of bins is preferred
  mp_Davg = mpDavg
  mp_D50 = gsdGetSizeOfPercentile( 50.0 )
  ;
  local _minDim = math.min( mv_H, mv_W )
  if global.dim == 3 then
    _minDim = math.min( _minDim, mv_D )
  end_if
  mp_PhiVavg = ( _minDim / mp_Davg  )
  mp_PhiV50  = ( _minDim / mp_D50 )
  ;
  ft_OverlapRatios ;{o: mp_OR{max, min, avg}}
  ;
  mp_CNb = bcnMeasure
  ;
  mp_nLNc = 0
  mp_nLNgg = 0
  mp_nLNgw = 0
  mp_nFJc = 0
  mp_nCBb = 0
  mp_nPBb = 0
  mp_nSBb = 0
  mp_nFJe = 0
  mp_nFJb = 0
  mp_nFJiB = 0
  mp_nFJiG = 0
  mp_nFJiS = 0
  mp_nFJiU = 0
  loop foreach local cp contact.list.all
    if ft_cLinearBased(cp) then
      if contact.active(cp) then
        mp_nLNc = mp_nLNc + 1
        if ft_cGrainGrain(cp) then
          mp_nLNgg = mp_nLNgg + 1
        else ; must be grain-wall contact
          mp_nLNgw = mp_nLNgw + 1
        end_if
      end_if
    end_if
    if contact.model(cp) == 'linearcbond' then
      if contact.prop(cp, 'cb_state') == 3 then
        mp_nCBb = mp_nCBb + 1
      end_if
    else if contact.model(cp) == 'linearpbond' then
      if contact.prop(cp, 'pb_state') == 3 then
        mp_nPBb = mp_nPBb + 1
      end_if
    else if contact.model(cp) == 'softbond' then
      if   (contact.prop(cp, 'sb_state') == 3) ...
         | (contact.prop(cp, 'sb_state') == 4) ...
         | (contact.prop(cp, 'sb_state') == 5) then
        mp_nSBb = mp_nSBb + 1
      end_if
    else if contact.model(cp) == 'flatjoint' then
      mp_nFJc = mp_nFJc + 1
      ;
      local nE
      if global.dim == 3 then
        nE = contact.prop(cp, 'fj_nr') * contact.prop(cp, 'fj_nal')
      else ; 2D model
        nE = contact.prop(cp, 'fj_nr')
      end_if
      mp_nFJe = mp_nFJe + nE
      loop for ( local e = 1, e <= nE, e = e + 1 )
        contact.prop(cp, 'fj_elem') = e
        if contact.prop(cp, 'fj_state') == 3 then
          mp_nFJb = mp_nFJb + 1
        end_if
      end_loop
      ;
      if      contact.prop(cp, 'fj_mtype') == 1 then
        mp_nFJiB = mp_nFJiB + 1
      else if contact.prop(cp, 'fj_mtype') == 2 then
        mp_nFJiG = mp_nFJiG + 1
      else if contact.prop(cp, 'fj_mtype') == 3 then
        mp_nFJiS = mp_nFJiS + 1
      else if contact.prop(cp, 'fj_mtype') == 4 then
        mp_nFJiU = mp_nFJiU + 1
      end_if
    end_if
  end_loop
end
;------------------------------------------------
fish define udm_computeMicroStrucProps
; If cm_matType == 5 then
;   compute the microstructural properties of the user-defined material and store in
;   global variables.
;
  local myStr =         'The FISH function udm_computeMicroStrucProps must be provided by user'
        myStr = myStr + ' when cm_matType == 5. This is done by redefining the function.'
  system.error = myStr
end
;==================================================================================================
program return
;EOF: ft.fis